---
layout: post
title: Dynamic Prefix Sums with Fenwick Tree
date: 2023-10-12 03:01:00
description: The Fenwick Tree, also known as the Binary Indexed Tree (BIT), its applications, and its Rust implementation.
tags: rust, algorithms, data-structures
categories: notes
thumbnail: assets/img/fenwick/FT_level_2.svg
giscus_comments: true
---
The *Fenwick Tree*, also known as the *Binary Indexed Tree* (BIT), is a popular and elegant data structure that maintains the prefix sums of a dynamic array. Indeed, we can update values in the original array and still answer prefix sum queries. Both update and sum queries can be performed in logarithmic time. For an introduction to prefix sums and their applications, take a look at [*'The Power of Prefix Sums'*](/rossano/blog/2023/prefixsums) post. 
Your provided text appears to be mostly correct grammatically, but there are a few minor improvements for clarity and style:

More precisely, the Fenwick tree solves the following problem.

*We have an array $$A[1,n]$$ of integers, and we would like to support the following operations:*

- *`sum(i)` returns the sum of the elements in $$A[1..i]$$;*
- *`add(i, v)` adds the value $$v$$ to the entry $$A[i]$$.*

The Fenwick tree efficiently handles these queries in $$\Theta(\log n)$$ time while using linear space. In fact, the Fenwick tree is an *implicit* data structure, which means it requires only $$O(1)$$ additional space in addition to the space needed to store the input data (the array $$A$$ in our case).

In describing the solutions, we are going to use the following array $$A$$ as a running example. Notice that we are using a one-based indexing for the array.

<div class="row mt-1">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/Array.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

<br>
#### Two Trivial Solutions
Let's describe two trivial solutions for the problem above.

- The first solution simply stores $$A$$ as it is. This way, `sum(i)` is solved by scanning the array in $$\Theta(n)$$ time, and `add(i, v)` is solved in $$O(1)$$ time.
- The second solution stores the prefix-sums of $$A$$. This way, `sum(i)` is solved in $$O(1)$$ time, and `add(i, v)` is solved by modifying all the entries up to position $$i$$ in $$\Theta(n)$$ time.

The `sum`/`add` query time tradeoffs of these solutions are clearly unsatisfactory.


<br>
##### Fenwick Teee Level by Level
The Fenwick Teee provides better tradeoffs for this problem. 
In our description, we will gradually introduce this data structure by constructing it level by level.

To start, let's simplify the original problem slightly. In this variant, we'll focus on solving `sum` queries only for positions that are powers of $$2$$, like positions $$1$$, $$2$$, $$4$$, and $$8$$ in our array $$A$$. The solution of this variant will be the first level of our Fenwick Tree.

The idea for solving this relaxed variant is to sparsify the second trivial solution above, storing only the prefix sums of positions that we need for queries.
The figure below illustrates this solution as a tree, with a fictitious root node named $$0$$ and child nodes named $$1$$, $$2$$, $$4$$, and $$8$$, each storing the sum up to the corresponding power of $$2$$. Additionally, below every node, we provide the range of positions it covers. For instance, node $$4$$ covers positions in the range $$[1, 4]$$.

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_level_1.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

We address the queries of the simplified problem as follows:

1. The `sum(i)` query is straightforward. We simply access node $$i$$, which takes constant time. Of course, this only works for indexes $$i$$ that are a power of $$2$$.

2. For the `add(i, v)` query we need to add $$v$$ to all nodes covering ranges that include position $$i$$. For example, for the query `add(3, 10)`, we add the value $$10$$ to nodes $$4$$ and $$8$$. In general, first we have to find the smallest power of $$2$$ greater than $$i$$, let's call it $$j$$. Then, we add $$v$$ to nodes $$j, 2j, 2^2j, 2^3j, \ldots$$. This query takes $$\Theta(\log n)$$ time.

Now, can we extend this solution to support `sum` queries on more positions?

We observe that we're not currently supporting queries for positions within the ranges between consecutive powers of $$2$$. For instance, positions in the range $$[5,7]$$, which fall between $$2^2$$ and $$2^3$$.
But wait! Enabling queries for this subarray is just a smaller instance of our original problem. Therefore, we can apply the same strategy by adding a new level to our tree. If the subarray is $$A[l..r]$$, the new level will support the `sum(i)` query for any $$i$$ such that $$i-l+1$$ is a power of $$2$$.

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_level_2.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

Your text is clear, but some parts can be rephrased for improved flow and readability. Here's a revised version:

Our two-level tree can now handle  `sum(i)` queries also for positions that are the sum of two powers of $$2$$. Why? Consider a position $$i$$ expressed as $$2^{k'}+2^{k}$$, where $$k'>k$$. We can decompose the range $$[1,i]$$ into two subranges: $$[1,2^{k'}]$$ and $$[2^{k'}+1,2^{k'}+2^{k}=i]$$. Both of these subranges are covered by nodes in our tree. Specifically, range $$[1,2^{k'}]$$ is covered by node $$2^{k'}$$ at the first level, while $$[2^{k'}+1,2^{k'}+2^{k}=i]$$ is covered by node $$i$$ at the second level.

For example, let's consider the query `sum(5)`. We can handle this in our two-level tree because $$5=2^2+2^0$$. Consequently, the range $$[1,5]$$ is divided into $$[1,4]$$ and $$[5,5]$$, and the result (which is $$6$$) is obtained by summing the values of nodes $$2^2=4$$ and $$2^2+2^0=5$$.

Which positions are still not supported for `sum` queries? Positions that are neither powers of $$2$$ nor the sum of two powers of $$2$$. In our example, with $$n=8$$, only position $$7=2^2+2^1+2^0$$ falls into this category. So, what do we do next? We add a new level to our tree to support queries for positions that are the sum of three powers of $$2$$.

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_level_3.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

That's all. This is the Fenwick tree for the array $$A$$. Now, let's make some observations:

1. While we've represented our solution as a tree, it can also be represented as an array $$FT$$ of size $$n+1$$, as shown in the figure above.
2. We no longer require the original array $$A$$ because any of its entries $$A[i]$$ can be obtained as $$A[i] = \text{sum}(i) - \text{sum}(i-1)$$. This is why the Fewniwck tree is an *implicit* data structure.
3. Let be $$h$$ equal to $$\lfloor \log (n) + 1 \rfloor$$, which is the length of the binary representation of any position in the range $$[1,n]$$. Since any position can be expressed as the sum of at most $$h$$ powers of $$2$$, the tree has no more than $$h$$ levels. In fact, the number of levels is either $$h$$ or $$h-1$$, depending on the value of $$n$$.

<br>
#### Querying a Fenwick Tree
Now, let's delve into the details of how to solve our `sum` and `add` queries on a Fenwick tree. Since the Fenwick Tree is also known as a binary indexed tree, it could be helpful to examine the binary representation of positions when working on a query.

We'll begin with the `sum(i)` query. For example, consider the case where $$i=7$$. The binary representation of $$7$$ is <TT>0111</TT>, indicating that $$7$$ can be expressed as the sum of three powers of 2. Consequently, the range $$[1,7]$$ can be divided into three subranges: $$[1,4]$$, $$[5,6]$$, and $$[7,7]$$. 
These subranges are each covered by nodes in the tree, specifically nodes $$4$$, $$6$$, and $$7$$, with one node at each level of the tree. The sum of the values in these nodes provides the result of the query. It's worth noting that we start from the target node ($$7$$ in this case) and move to its parent (node $$6$$), its grandparent (node $$4$$), and so on, until we reach the fictitious node $$0$$.

It's evident that to solve the `sum` query, we require the `parent` operation which allows to move from a node to its parent.

<br>
##### Compute the Parent of a Node
We want to compute the `parent` of a node, and we want to do it quickly and without representing the structure of the tree.
To understand what we need, let's examine the binary representations of the IDs of the nodes involved in answering the previous query.

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_bin_1.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

Can you find out any pattern? Surprisingly, the binary representation of a node's parent can be obtained by removing the rightmost <TT>1</TT> from the binary representation of its children.

Let's explore why this method works.

Suppose we have a node $$i$$, and its range is $$[j,i]$$ for some $$j$$. Its children will be nodes $$i+2^0$$, $$i+2^1$$, $$i+2^2$$, and so on, spanning ranges $$[j+1, i+2^0]$$, $$[j+1, i+2^1]$$, $$[j+1, i+2^2]$$, and so forth. The binary representation of any of these children is identical to that of $$i$$, except for the addition of the rightmost <TT>1</TT> (due to the term $$2^k$$).

Now, we need a clever bit-trick to efficiently obtain the parent of a node. Based on our previous discussion, it's evident that we need a way to remove the rightmost <TT>1</TT> from the binary representation of a node $$i$$. This rightmost <TT>1</TT> can be isolated by computing $$k = i {\tt \&} -i$$. Thus, $$i-k$$ is the parent of $$i$.

In fact, the two's complement of an $$N$$-bit number is the complement with respect to $$2^N$$.
For example, $$7$$ is <TT>0111</TT> in binary and its two's complement is <TT>1001</TT>
and <TT>0111</TT> + <TT>1001</TT> is <TT>10000</TT> equals $$2^5$$.
The two's complement corresponds to inverting all the bits in the binary representation of a number and adding one. This means that the binary encodings of a number and its inverse match bit by bit, differing only after their rightmost <TT>1</TT>. When we compute their logical AND, only the rightmost <TT>1</TT> survives. Thus, the final subtraction cancels this bit from $$i$$, as required.

For example,

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_bin_2.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>


Now, let's consider the `add(i, v)` query. We need to add the value of `v` to each node whose range include the position $$i$$.

Certainly, node $$i$$ is one of these nodes since its range ends at $$i$$. Additionally, the right siblings of node $$i$$ also encompass the position $$i$$ in their ranges. This is because siblings share the same starting position, and right siblings have increasing sizes. The right siblings of the parent of node $$i$$, the right siblings of the grandparent, and so on also contain position $$i$$.

It might seem like we have to modify a large number of nodes. However, a simple observation reveals that this number is at most $$\log n$$. This is because, each time we move from a node to its right sibling or to the right sibling of its parent, the size of the covered range at least doubles. And
a range cannot double more than $$\log n$$ times.

Now, let's discuss how to find the sequence of nodes to update for a given position $$i$$. As mentioned earlier, node $$i$$ is the first node to update. To find the next node, we can use a couple of bit tricks.

For example, assume that $$i=5$$ is teh current node. The next node is its closest right sibling, which is $$6$$. Let's take a closer look at their binary representations.

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_bin_3.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

Can you find out any pattern?

It seems that we need to isolate the rightmost <TT>1</TT> in $$5$$, which is <TT>0001</TT>, and add it to $$5$$ to obtain $$6$$. Is this always the correct approach?

Let's try it with another node. The right sibling of the parent of $$6$$ (and, therefore, of $$5$$) is $$8$$.

<div class="row mt-3 ">
    <div class="col-sm mt-3 mt-md-0">
        {% include figure.html path="assets/img/fenwick/FT_bin_4.svg" class="img-fluid rounded z-depth-1" zoomable=true %}
    </div>
</div>

The rigthmost <TT>1</TT> in $$6$$ is <TT>0010</TT> (i.e., $$2$$) and $$6+2=8$$. Cool!

Why is this method correct? The binary representation of a node and its siblings matches, except for the position of the rightmost <TT>1</TT>. When we move from a node to its right sibling, this rightmost <TT>1</TT> shifts one position to the left. Adding this rightmost <TT>1</TT> to a node accomplishes the required shift, as seen when we add $$5$$ to its rightmost <TT>1</TT>.

Now, consider the ID of a node that is the last child of its parent. In this case, the rightmost and second rightmost <TT>1</TT> are adjacent. To obtain the right sibling of its parent, we need to remove the rightmost <TT>1</TT> and shift the second rightmost <TT>1</TT> one position to the left.

Thankfully, this effect is one again achieved by adding the rightmost <TT>1</TT> to the node's ID.

<br>
#### Fenwick Tree in Rust
Possible implementations of `sum` and `add` are reported below.

\begin{cpp}
int sum(int idx) {
  int s = 0;
  while(idx != 0) {
      s += B[idx];
      idx -= idx & -idx; // parent(idx)
  }
  return s;
}

void add(int idx, int v){
  while(idx <= N) {
    B[idx] += v;
    idx += idx & -idx; // get_next(idx)
  }
}

\end{cpp}

<br>
##### Queries Time Complexity
What are the time complexities of `sum` and `add`?

Clearly, `sum` takes time proportional to the height of the tree and, thus,
takes $$\Theta(\log n)$$ time.
This is also the time completity of `add`. To see this we observe that every time
we move to the right sibling of the current node or the right sibling of its parent,
the rightmost <TT>1</TT> of its binary representation is moved at least
one position to the left. This is possible at most $$\log n$$ times.