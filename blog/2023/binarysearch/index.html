<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="E0vDQCYLRDz-hSNBg2blH7KJpNUSxElnYzNlfGC_xjo"> <meta name="msvalidate.01" content="AB84189524C3D3ACAE3EA77DC5F97F11"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Applications of Binary Search | Rossano Venturini</title> <meta name="author" content="Rossano Venturini"> <meta name="description" content="Binary search is undeniably one of the most renowned and fundamental algorithms in computer science. In these notes, we delve into problems that can be solved using the idea of 'Binary Searching for the Answer'."> <meta name="keywords" content="algorithm, data-structures, rust, efficiency"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/rossano/assets/img/favicon.png"> <link rel="stylesheet" href="/rossano/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pages.di.unipi.it/rossano/blog/2023/binarysearch/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/rossano/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/rossano/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/rossano/">Rossano Venturini</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/rossano/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/rossano/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/rossano/publications/">Publications</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/rossano/competitive/">Competitive Programming and Contests</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/rossano/courses/">Teaching activity</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Applications of Binary Search</h1> <p class="post-meta">September 23, 2023</p> <p class="post-tags"> <a href="/rossano/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/rossano/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust,</a>   <a href="/rossano/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms</a>     ·   <a href="/rossano/blog/category/notes"> <i class="fas fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>Binary search is undoubtedly one of computer science’s most well-known and fundamental algorithms. This elegant and efficient algorithm searches for a given key within a sorted array of \(n\) items.</p> <p>Binary search repeatedly divides the search range in half until the target element is found or the search range becomes empty, resulting in a time complexity of \(\Theta(\log n)\). This is one of the easiest applications of the <em>Divide-and-Conquer paradigm</em>.</p> <p><br></p> <h4 id="divide-and-conquer-paradigm">Divide-and-Conquer Paradigm</h4> <p>The divide-and-conquer paradigm tackles a complex problem by breaking it down into smaller, more manageable subproblems of the same type. These subproblems are addressed recursively, and their solutions are combined to yield the solution for the original problem.</p> <p>More precisely, a divide-and-conquer-based algorithm follows three main steps:</p> <ul> <li> <strong>Divide</strong>: The initial problem instance is partitioned into smaller subinstances of the same problem.</li> <li> <strong>Solve</strong>: These subinstances are then solved recursively. If a subinstance reaches a certain manageable size, a straightforward approach is employed to solve it directly.</li> <li> <strong>Combine</strong>: The solutions obtained from the subinstances are combined to obtain the final solution for the original, larger instance of the problem.</li> </ul> <p><br></p> <h4 id="binary-search-implementation">Binary Search Implementation</h4> <p>We can apply the above paradigm to search for a key in a sorted array of \(n\) elements within \(\Theta(\log n)\) comparisons.</p> <ul> <li> <strong>Divide</strong>: The array is divided into two roughly equal halves, centering around the middle element of the array.</li> <li> <strong>Solve</strong>: Compare the middle element of the array with the searched key. If the middle element is a match, the search stops successfully. If not, we recursively search for the key only in one of the two halves that may contain based on whether the desired key is greater or lesser than the middle element.</li> <li> <strong>Combine</strong>: There is nothing to combine. The algorithm simply reports the final answer.</li> </ul> <p>A Rust implementation of binary search is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span>   <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">),</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>    <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">None</span>
<span class="p">}</span>
</code></pre></div></div> <p>The generic implementation above works for types that are <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">Ord</code></a>. <code class="language-plaintext highlighter-rouge">Ord</code> is the trait for types that form a total order. The method <code class="language-plaintext highlighter-rouge">cmp</code> returns an <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">Ordering</code></a> between two elements: In our case, the <code class="language-plaintext highlighter-rouge">key</code> we are looking for and the element in the middle. We use the result of this comparison to check for a match or to move either <code class="language-plaintext highlighter-rouge">low</code> after <code class="language-plaintext highlighter-rouge">middle</code> or <code class="language-plaintext highlighter-rouge">high</code> to <code class="language-plaintext highlighter-rouge">middle</code>. Note that the position <code class="language-plaintext highlighter-rouge">high</code> is not included in the range.</p> <p>It is worth noticing the expression <code class="language-plaintext highlighter-rouge">middle = low + (high - low)/2</code> to compute the position in the middle of the current range. A lot of existing implementations on the net use instead the expression <code class="language-plaintext highlighter-rouge">middle = (low + high) / 2</code>, which is buggy. Indeed, it leads to overflow if <code class="language-plaintext highlighter-rouge">low + high</code> is greater than <code class="language-plaintext highlighter-rouge">usize::MAX</code>.</p> <p>It is also important to observe that when there are multiple occurrences of the searched key, the function returns the position of the first encountered occurrence, not necessarily the first occurrence in the vector. This behavior aligns with the implementation of <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search" rel="external nofollow noopener" target="_blank">binary search</a> in the Rust Standard Library. However, it is often very useful to report the position of the first (or last) occurrence of the searched key. We can obtain this behavior with the following implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span> <span class="c1">// note that high is excluded</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">);</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span>
            <span class="p">}</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this implementation, when a match is found, we do not immediately return its position. Instead, we update the <code class="language-plaintext highlighter-rouge">ans</code> variable and set <code class="language-plaintext highlighter-rouge">high</code> to the position of this occurrence. This way, we continue the search in the first half of the array, seeking additional occurrences of the <code class="language-plaintext highlighter-rouge">key</code>. If there are more matches, <code class="language-plaintext highlighter-rouge">ans</code> will be further updated with smaller positions.</p> <p>As a useful exercise you could try to modify the code above to return the smallest position such that the element at that position is greater than or equal to <code class="language-plaintext highlighter-rouge">key</code>. In other word, if the <code class="language-plaintext highlighter-rouge">key</code> is not in the slice, it returns the position of its successor.</p> <p>Instead of implementing the code above, we can find the first (or even the last) occurrence of a key with <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.partition_point" rel="external nofollow noopener" target="_blank">partition_point</a> method of the standard library. This method is even more generic that our code above. Indeed, it returns the index of the partition point in a sorted vector according to any given predicate.</p> <p><br></p> <h4 id="binary-search-the-answer">Binary Search the Answer</h4> <p>Consider a problem where all the possible candidate answers are restricted to a range of values between certain <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> possible answers. In other words, any candidate answer \(x\) falls within the range <code class="language-plaintext highlighter-rouge">[low, high)</code>. We also have a boolean predicate <code class="language-plaintext highlighter-rouge">pred</code> defined on the candidate answers that tells us if an answer is good or not for our aims. Our goal is to find the largest good answer.</p> <p>When no assumptions are made about the predicate, we cannot do better than evaluating the predicate on all the possible answers. So, the number of times we evaluate the predicate is \(\Theta(n)\), where \(n = high-low\) is the number of possible answers.</p> <p>Instead, if the predicate is <strong>monotone</strong>, we can <em>binary search the answer</em> to find it with \(\Theta(\log n)\) evaluations. This strategy is implemented by the generic function below.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">FromPrimitive</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">Num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialOrd</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">binary_search_range</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">low</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Num</span> <span class="o">+</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="n">FromPrimitive</span> <span class="o">+</span> <span class="nb">Copy</span><span class="p">,</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="nn">FromPrimitive</span><span class="p">::</span><span class="nf">from_u64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">match</span> <span class="nf">pred</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="nn">T</span><span class="p">::</span><span class="nf">one</span><span class="p">();</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>The function takes the extremes (of type <code class="language-plaintext highlighter-rouge">T</code>) of the range and the predicate as an argument. We use the external crate <a href="https://docs.rs/num/latest/num/" rel="external nofollow noopener" target="_blank">Num</a> to require some basic arithmetic operations for type <code class="language-plaintext highlighter-rouge">T</code>. The function returns the largest element of the range satisfying the predicate, or <code class="language-plaintext highlighter-rouge">None</code> if there is no such element.</p> <p>Let’s use this function to solve problems.</p> <p><br></p> <h5 id="sqrt">Sqrt</h5> <p>An example is the problem <em><a href="https://leetcode.com/problems/sqrtx/" rel="external nofollow noopener" target="_blank">Sqrt</a></em>.</p> <p><em>We are given a non-negative integer \(v\) and we want to compute the square root of \(v\) rounded down to the nearest integer.</em></p> <p>The possible answers are in \([0, v]\). For each candidate answer \(x\), the predicate is \(p(x) = x^2 &lt;= v\). Thus, we can find the result in \(\Theta(\log v)\) time.</p> <p>Thus, a one-line solution is</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="social-distancing">Social Distancing</h5> <p>Let’s consider <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1038" rel="external nofollow noopener" target="_blank">another problem</a>.</p> <p><em>We have a sequence of \(n\) mutually-disjoint intervals. The extremes of each interval are non-negative integers. We aim to find \(c\) integer points within the intervals such that the smallest distance \(d\) between consecutive selected points is <strong>maximized</strong>.</em></p> <p>Guess what? A solution to this problem binary searches the answer, the target distance \(d\). Why is this possible? If a certain distance is feasible (i.e., there exists a selection of points at that distance), then any smaller distance is also feasible. Thus, the feasibility is a monotone boolean predicate that we can use to binary search the answer.</p> <p>As the candidate answers range from \(1\) to \(l\), where \(l\) is the overall length of the intervals, the solution takes \(\Theta(\log l)\) evaluations of the predicate.</p> <p>What’s the cost of evaluating the predicate? Well, we first sort the intervals. Now, we can evaluate any candidate distance \(d'\) by scanning the sorted intervals from left to right. First, we select the left extreme of the first interval as the first point. Then, we move over the intervals, and we choose greedly the first point, which is at a distance at least \(d'\) from the previous one. Thus, an evaluation of the predicate takes \(\Theta(n)\) time.</p> <p>The overall running time is \(\Theta(n\log l)\).</p> <p>A Rust implementation of this strategy is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">select_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">interval</span><span class="p">|</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">interval</span><span class="na">.1</span> <span class="o">-</span> <span class="n">interval</span><span class="na">.0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// overall length</span>

    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="p">{</span>
        <span class="c1">// there is no solution</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intervals</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="c1">// A closure implements our predicate</span>
    <span class="k">let</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">|</span><span class="n">d</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">last_selected</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">interval</span> <span class="k">in</span> <span class="n">intervals</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="na">.1</span> <span class="p">{</span>
                <span class="n">last_selected</span> <span class="o">=</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">);</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span>
    <span class="p">};</span>

    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="other-problems">Other Problems</h5> <ul> <li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" rel="external nofollow noopener" target="_blank">Find First and Last Position of Element in Sorted Array</a></li> <li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" rel="external nofollow noopener" target="_blank">Find the minimum in a rotated sorted array</a></li> <li><a href="https://leetcode.com/problems/find-peak-element/" rel="external nofollow noopener" target="_blank">Search for a peak in an (unsorted) array</a></li> </ul> <p>These notes are for the <a href="/rossano/competitive/"><em>“Competitive Programming and Contests”</em></a> course at Università di Pisa.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2024/handson12425/">HandsOn 1 24/25</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson32324/">HandsOn 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson22324/">HandsOn 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/mosalgorithm/">Mo's Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/fenwick/">Dynamic Prefix Sums with Fenwick Tree</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"rossanoventurini/webpage","data-repo-id":"R_kgDOKRTPSw","data-category":"General","data-category-id":"DIC_kwDOKRTPS84CZ7tz","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Rossano Venturini. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/rossano/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/rossano/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/rossano/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/rossano/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/rossano/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRWXE6TB2L"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LRWXE6TB2L");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"e35e6134ceef91b419bad00adc81df84"});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>