<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="E0vDQCYLRDz-hSNBg2blH7KJpNUSxElnYzNlfGC_xjo"> <meta name="msvalidate.01" content="AB84189524C3D3ACAE3EA77DC5F97F11"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Dynamic Prefix Sums with Fenwick Tree | Rossano Venturini</title> <meta name="author" content="Rossano Venturini"> <meta name="description" content="The Fenwick Tree, also known as the Binary Indexed Tree (BIT), efficiently manages the prefix sum of an array, even as it undergoes updates. In these notes, we introduce this elegant data structure and describe a basic Rust implementation."> <meta name="keywords" content="algorithm, data-structures, rust, efficiency"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/rossano/assets/img/favicon.png"> <link rel="stylesheet" href="/rossano/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pages.di.unipi.it/rossano/blog/2023/fenwick/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/rossano/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/rossano/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/rossano/">Rossano Venturini</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/rossano/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/rossano/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/rossano/publications/">Publications</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/rossano/competitive/">Competitive Programming and Contests</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/rossano/courses/">Teaching activity</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Dynamic Prefix Sums with Fenwick Tree</h1> <p class="post-meta">October 13, 2023</p> <p class="post-tags"> <a href="/rossano/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/rossano/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust,</a>   <a href="/rossano/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms,</a>   <a href="/rossano/blog/tag/data-structures"> <i class="fas fa-hashtag fa-sm"></i> data-structures</a>     ·   <a href="/rossano/blog/category/notes"> <i class="fas fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The <em>Fenwick Tree</em>, also known as the <em>Binary Indexed Tree</em> (BIT), is a popular and elegant data structure that maintains the prefix sums of a dynamic array<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. With this data structure we can update values in the original array and still answer prefix sum queries. Both operations runs in logarithmic time.</p> <p>More precisely, the Fenwick tree solves the following problem.</p> <p><em>We have an array \(A[1,n]\) of integers, and we would like to support the following operations:</em></p> <ul> <li><em><code class="language-plaintext highlighter-rouge">sum(i)</code> returns the sum of the elements in \(A[1..i]\);</em></li> <li><em><code class="language-plaintext highlighter-rouge">add(i, v)</code> adds the value \(v\) to the entry \(A[i]\).</em></li> </ul> <p>The Fenwick tree efficiently handles these queries in \(\Theta(\log n)\) time while using linear space. In fact, the Fenwick tree is an <em>implicit</em> data structure, which means it requires only \(O(1)\) additional space in addition to the space needed to store the input data (the array \(A\) in our case).</p> <p>In our descritpion, we are going to use the following array \(A\) as a running example. Notice that we are using a one-based indexing for the array.</p> <div class="row mt-1"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/Array.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p><br></p> <h4 id="two-trivial-solutions">Two Trivial Solutions</h4> <p>Let’s describe two trivial solutions for the problem above.</p> <p>The first solution simply stores \(A\) as it is. This way, <code class="language-plaintext highlighter-rouge">sum(i)</code> is solved by scanning the array in \(\Theta(n)\) time, and <code class="language-plaintext highlighter-rouge">add(i, v)</code> is solved in \(O(1)\) time.</p> <p>The second solution, instead, stores the prefix-sums of \(A\). This way, <code class="language-plaintext highlighter-rouge">sum(i)</code> is solved in \(O(1)\) time, and <code class="language-plaintext highlighter-rouge">add(i, v)</code> is solved by modifying all the entries up to position \(i\) in \(\Theta(n)\) time.</p> <p>The <code class="language-plaintext highlighter-rouge">sum</code>/<code class="language-plaintext highlighter-rouge">add</code> query time tradeoffs of these solutions are clearly unsatisfactory.</p> <p><br></p> <h3 id="fenwick-tree-level-by-level">Fenwick Tree, Level by Level</h3> <p>The Fenwick Tree provides better tradeoffs for this problem. In our description, we will gradually introduce this data structure by constructing it level by level.</p> <p>To start, let’s simplify the original problem slightly. In this variant, we’ll focus on solving <code class="language-plaintext highlighter-rouge">sum</code> queries only for positions that are powers of \(2\), like positions \(1\), \(2\), \(4\), and \(8\) in our array \(A\). The solution of this variant will be the first level of our Fenwick Tree.</p> <p>The idea for solving this relaxed variant is to sparsify the second trivial solution above, storing only the prefix sums of positions that we need for queries. The figure below illustrates this solution as a tree, with a fictitious root node named \(0\) and child nodes named \(1\), \(2\), \(4\), and \(8\), each storing the sum up to the corresponding power of \(2\). Additionally, below every node, we provide the range of positions it covers. For instance, node \(4\) covers positions in the range \([1, 4]\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>We address the queries of the simplified problem as follows:</p> <ul> <li> <p>The <code class="language-plaintext highlighter-rouge">sum(i)</code> query is straightforward. We simply access node \(i\). Of course, this only works for indexes \(i\) that are a power of \(2\).</p> </li> <li> <p>For the <code class="language-plaintext highlighter-rouge">add(i, v)</code> query we need to add \(v\) to all nodes covering ranges that include position \(i\). For example, for the query <code class="language-plaintext highlighter-rouge">add(3, 10)</code>, we add the value \(10\) to nodes \(4\) and \(8\). In general, first we have to find the smallest power of \(2\) greater than \(i\), let’s call it \(j\). Then, we add \(v\) to nodes \(j, 2j, 2^2j, 2^3j, \ldots\).</p> </li> </ul> <p>Observe that <code class="language-plaintext highlighter-rouge">sum</code> takes constanti time and <code class="language-plaintext highlighter-rouge">add</code> takes \(\Theta(\log n)\) time. Hooray! We are within our target time complexity. Now, can we extend this solution to support <code class="language-plaintext highlighter-rouge">sum</code> queries on more positions?</p> <p>We observe that we’re not currently supporting queries for positions within the ranges between consecutive powers of \(2\). For instance, positions in the range \([5,7]\), which fall between \(2^2\) and \(2^3\). But wait! Enabling queries for this subarray is just a smaller instance of our original problem. Therefore, we can apply the same strategy by adding a new level to our tree. If the subarray is \(A[l..r]\), the new level will support the <code class="language-plaintext highlighter-rouge">sum(i)</code> query for any \(i\) such that \(i-l+1\) is a power of \(2\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_2.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Our two-level tree can now handle <code class="language-plaintext highlighter-rouge">sum(i)</code> queries also for positions that are the sum of two powers of \(2\). Why? Consider a position \(i\) expressed as \(2^{k'}+2^{k}\), where \(k'&gt;k\). We can decompose the range \([1,i]\) into two subranges: \([1,2^{k'}]\) and \([2^{k'}+1,2^{k'}+2^{k}=i]\). Both of these subranges are covered by nodes in our tree. Specifically, range \([1,2^{k'}]\) is covered by node \(2^{k'}\) at the first level, while \([2^{k'}+1,2^{k'}+2^{k}=i]\) is covered by node \(i\) at the second level.</p> <p>For example, let’s consider the query <code class="language-plaintext highlighter-rouge">sum(5)</code>. We can handle this in our two-level tree because \(5=2^2+2^0\). Consequently, the range \([1,5]\) is divided into \([1,4]\) and \([5,5]\), and the result (which is \(6\)) is obtained by summing the values of nodes \(2^2=4\) and \(2^2+2^0=5\).</p> <p>Which positions are still not supported for <code class="language-plaintext highlighter-rouge">sum</code> queries? Positions that are neither powers of \(2\) nor the sum of two powers of \(2\). In our example, with \(n=8\), only position \(7=2^2+2^1+2^0\) falls into this category. So, what do we do next? We add a new level to our tree to support queries for positions that are the sum of three powers of \(2\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_3.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>That’s all. This is the Fenwick tree for the array \(A\). Now, let’s make some observations:</p> <ol> <li>While we’ve represented our solution as a tree, it can also be represented as an array \(FT\) of size \(n+1\), as shown in the figure above.</li> <li>We no longer require the original array \(A\) because any of its entries \(A[i]\) can be obtained as \(A[i] = \text{sum}(i) - \text{sum}(i-1)\). This is why the Fewniwck tree is an <em>implicit</em> data structure.</li> <li>Let be \(h\) equal to \(\lfloor \log (n) + 1 \rfloor\), which is the length of the binary representation of any position in the range \([1,n]\). Since any position can be expressed as the sum of at most \(h\) powers of \(2\), the tree has no more than \(h\) levels. In fact, the number of levels is either \(h\) or \(h-1\), depending on the value of \(n\).</li> </ol> <p>Now, let’s delve into the details of how to solve our <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">add</code> queries on a Fenwick tree.</p> <p><br></p> <h4 id="answering-a-sum-query">Answering a <code class="language-plaintext highlighter-rouge">sum</code> query</h4> <p>Let’s start by discussing the <code class="language-plaintext highlighter-rouge">sum(i)</code> query. Based on the previous discussion, solving this query involves beginning at node \(i\) and traversing up the tree to reach node \(0\). Thus, <code class="language-plaintext highlighter-rouge">sum</code> takes time proportional to the height of the tree, resulting in a time complexity of \(\Theta(\log n)\).</p> <p>For a running example, let’s take the case where \(i=7\). We start at node \(7\) and move to its parent (node \(6\)), its grandparent (node \(4\)), and stop at its great-grandparent (the fictitious node \(0\)), summing their values along the way. This works because the ranges of these nodes (\([1,4]\), \([5,6]\), and \([7,7]\)) collectively cover the queried range \([1,7]\).</p> <p>It’s important to note that answering a <code class="language-plaintext highlighter-rouge">sum</code> query becomes straightforward if we were allowed to store the tree’s structure. However, a significant part of the Fenwick tree’s elegance lies in the fact that storing the tree is not actually necessary. This is because we can efficiently navigate from a node to its parent using a few bit-tricks. This is the reason why the Fenwick tree is also referred to as the Binary Indexed Tree.</p> <p><br></p> <h5 id="compute-the-parent-of-a-node">Compute the Parent of a Node</h5> <p>We want to compute the <code class="language-plaintext highlighter-rouge">parent</code> of a node, and we want to do it quickly and without representing the structure of the tree.</p> <p>Let’s examine the binary representations of the IDs of the nodes involved in answering the previous query.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Can you find out any pattern? Surprisingly, the binary representation of a node’s parent can be obtained by removing the trailing one (i.e., rightmost bit set to <tt>1</tt>) from the binary representation of its children.</p> <p>Let’s explore why this method works.</p> <p>Suppose we have a node \(i\), and its range is \([j,i]\) for some \(j\). Its children will be nodes \(i+2^0\), \(i+2^1\), \(i+2^2\), and so on, spanning ranges \([j+1, i+2^0]\), \([j+1, i+2^1]\), \([j+1, i+2^2]\), and so forth. The binary representation of any of these children is identical to that of \(i\), except for the addition of the trailing one (due to the term \(2^k\)).</p> <p>Now, we need a clever bit-trick to efficiently obtain the parent of a node. Based on our previous discussion, it’s evident that we need a way to remove the trailing one from the binary representation of a node \(i\). The trailing one can be isolated by computing \(k = i {\tt \&amp;} -i\). Thus, \(i-k\) is the parent of \(i\).</p> <p>In fact, negative numbers are represented in <a href="https://en.wikipedia.org/wiki/Two%27s_complement" rel="external nofollow noopener" target="_blank">two’s complement</a> form. In this representation, the two’s complement of a number is obtained by taking the bitwise complement of the number and then adding one to it.</p> <p>For instance, if we have the binary number \(7\) as <tt>0111</tt>, its two’s complement, which represents \(-7\), is <tt>1001</tt>.</p> <p>The key property of the two’s complement is that it inverts all the bits in the binary representation of a number, except for the leftmost “trailing one. Thus, when we compute the logical AND of a number and its two’s complement, only the trailing one survives. Therefore, the final subtraction \(i-k\) effectively cancels out this bit from \(i\), as required.</p> <p>For example,</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_2.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p><br></p> <h4 id="performing-an-add">Performing an <code class="language-plaintext highlighter-rouge">add</code> </h4> <p>Now, let’s consider the operation <code class="language-plaintext highlighter-rouge">add(i, v)</code>. We need to add the value of <code class="language-plaintext highlighter-rouge">v</code> to each node whose range include the position \(i\).</p> <p>Certainly, node \(i\) is one of these nodes since its range ends at \(i\). Additionally, the right siblings of node \(i\) also encompass the position \(i\) in their ranges. This is because siblings share the same starting position, and right siblings have increasing sizes. The right siblings of the parent of node \(i\), the right siblings of the grandparent, and so on also contain position \(i\).</p> <p>It might seem like we have to modify a large number of nodes. However, a simple observation reveals that this number is at most \(\log n\). This is because, each time we move from a node to its right sibling or to the right sibling of its parent, the size of the covered range at least doubles. And a range cannot double more than \(\log n\) times.</p> <p>The figure below shows in red the nodes to modify for the operation <code class="language-plaintext highlighter-rouge">add(5, _)</code>.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_add.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Now that we know which are the nodes to modify for <code class="language-plaintext highlighter-rouge">add(i,_)</code>, let’s discuss how to compute these nodes with bit-tricks.</p> <p>Coninuing the above example, starting from \(i=5\), the next node to modify is its right sibling, node \(6\). Let’s take a closer look at their binary representations.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_3.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Can you find out any pattern?</p> <p>It seems that we need to isolate the trailing one in \(5\), which is <tt>0001</tt>, and add it to \(5\) to obtain \(6\). Is this always the correct approach?</p> <p>Let’s try it with another node. The right sibling of the parent of \(6\) (and, therefore, of \(5\)) is \(8\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_4.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>The trailing one in \(6\) is <tt>0010</tt> (i.e., \(2\)) and \(6+2=8\). Cool!</p> <p>Why is this method correct? The binary representation of a node and its siblings matches, except for the position of the trailing one. When we move from a node to its right sibling, this trailing one shifts one position to the left. Adding this trailing one to a node accomplishes the required shift, as seen when we add \(5\) to its trailing one.</p> <p>Now, consider the ID of a node that is the last child of its parent. In this case, the rightmost and second trailing one are adjacent. To obtain the right sibling of its parent, we need to remove the trailing one and shift the second trailing one one position to the left.</p> <p>Thankfully, this effect is one again achieved by adding the trailing one to the node’s ID.</p> <p>The time complexity of <code class="language-plaintext highlighter-rouge">add</code> query is \(\Theta(\log n)\), as we observe that each time we move to the right sibling of the current node or the right sibling of its parent, the trailing one in its binary representation shifts at least one position to the left. This can occur at most \(\lfloor \log n \rfloor +1\) times.</p> <p><br></p> <h4 id="fenwick-tree-in-rust">Fenwick Tree in Rust</h4> <p>Here, we present a minimal Rust implementation of a Fenwick tree. In this non-generic implementation, we’ve arbitrarily chosen to use <code class="language-plaintext highlighter-rouge">i64</code> as the type for the values. While we’ve transitioned to 0-based indexing for queries, internally, we still use the 1-based indexing to maintain consistency with the notes.</p> <p>For a more advanced implementation, it could be required to allow generic types and move away from the 1-based indexing. Additionally, there are various potential optimizations to enhance its performance. For more details, refer to <a href="/rossano/assets/pdf/papers/SPE21.pdf"><em>Practical trade-offs for the prefix-sum problem</em></a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">pub</span> <span class="k">struct</span> <span class="n">FenwickTree</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FenwickTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_len</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="cd">/// Indexing is 0-based, even if internally we use 1-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">next_sibling</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Indexing is 0-based, even if internally we use 1-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  

        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="k">self</span><span class="py">.tree</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">parent</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sum</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">range_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.sum</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">-</span> <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">self</span><span class="nf">.sum</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="nf">.trailing_zeros</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parent</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">-</span> <span class="k">Self</span><span class="p">::</span><span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next_sibling</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">+</span> <span class="k">Self</span><span class="p">::</span><span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="applications-of-fenwick-tree">Applications of Fenwick Tree</h5> <p>We present now three problems that can be solved with Fenwick Tree.</p> <p><br></p> <h5 id="counting-inversions-in-an-array">Counting Inversions in an Array</h5> <p><em>We are given an array \(A[1 .. n]\) of \(n\) positive integers. If \(1 \leq i &lt; j \leq n\) and \(A[i] &gt; A[j]\), then the pair \((i, j)\) is called an <strong>inversion</strong> of \(A\).</em></p> <p><em>The goal is to count the number of inversions of \(A\).</em></p> <p>We assume that the largest integer \(M\) in array \(A\) is in \(O(n)\). This assumption is important because we’re using a Fenwick Tree of size \(M\) and building such a data structure takes \(\Theta(M)\) time and space. If, on the other hand, \(M\) is too large, we need to sort array \(A\) and replace each element with its rank in the sorted array.</p> <p>Then, we use a Fenwick tree on an array \(B\) with \(M\) elements, initially all set to \(0\). We scan array \(A\) from left to right. When processing \(A[j]\), we set \(B[j]\) to \(1\). The number of elements larger than \(A[j]\) that we’ve already processed can be calculated using the <code class="language-plaintext highlighter-rouge">range_sum(j+1, M)</code> function.</p> <p>The running time is \(\Theta(n\log n)\). It’s worth noting that there is another popular solution with the same time complexity, which utilizes a variant of Merge Sort.</p> <p>A Rust implementation is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">counting_inversions</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">u64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">max</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">ft</span> <span class="o">=</span> <span class="nn">FenwickTree</span><span class="p">::</span><span class="nf">with_len</span><span class="p">(</span><span class="n">max</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">count</span><span class="p">:</span> <span class="nb">usize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">e</span> <span class="k">in</span> <span class="n">a</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">+=</span> <span class="n">ft</span><span class="nf">.range_sum</span><span class="p">((</span><span class="n">e</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">max</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">;</span>
        <span class="n">ft</span><span class="nf">.add</span><span class="p">(</span><span class="n">e</span> <span class="k">as</span> <span class="nb">usize</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">count</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="nested-segments">Nested Segments</h5> <p>This problem is from <a href="http://codeforces.com/problemset/problem/652/D?locale=en" rel="external nofollow noopener" target="_blank">CodeForces</a>.</p> <p><em>We are given \(n\) segments: \([l_1, r_1], [l_2, r_2], \ldots, [l_n, r_n]\) on a line. There are no coinciding endpoints among the segments.</em></p> <p><em>The task is to determine and report the number of other segments each segment contains.</em></p> <p>We can restate the problem as follows: <em>For the \(i\)-th segment, we want to count the number of segments \(j\) such that the following conditions hold: \(l_i &lt; l_j\) and \(r_j &lt; r_i\)</em>.</p> <p>This problem can be solved by employing the <a href="/rossano/blog/2023/sweepline/">sweep line algorithm</a> and a Fenwick tree. First, we build the Fenwick tree by adding \(1\) in each position that correspons to right endpoint of a segment. This way, a <code class="language-plaintext highlighter-rouge">sum(r)</code> reports the number of segments that end in the range \([1,r]\).</p> <p>Next, we let a sweep line process the segments in <strong>increasing order</strong> of their left endpoints. When we process the segment \([l_i,r_i]\), we compute <code class="language-plaintext highlighter-rouge">sum</code>\((r_i-1)\) as the result for the current segment. Before moving to the next segment, we add \(-1\) at position \(r_i\) to remove the contribution of the right endpoint of the current segment.</p> <p>The claim is that <code class="language-plaintext highlighter-rouge">sum</code>\((r_i-1)\) is the number of segments contained in \([l_i,r_i]\). This is because all the segments that start before \(l_i\) have already been processed, and their right endpoints have been removed from the Fenwick tree. Therefore, <code class="language-plaintext highlighter-rouge">sum</code>\((r_i-1)\) is the number of segments that start after \(l_i\) and end before \(r_i\).</p> <p><br></p> <h5 id="update-the-array">Update the Array</h5> <p>This <a href="http://www.spoj.com/problems/UPDATEIT/" rel="external nofollow noopener" target="_blank">problem</a> is from SPOJ.</p> <p><em>We are given an array \(A[1,n]\), initially all the entries are set to \(0\) and we would like to support two operations:</em> - <code class="language-plaintext highlighter-rouge">access(i)</code> <em>returns \(A[i]\);</em> - <code class="language-plaintext highlighter-rouge">range_uptade(l, r, v)</code> <em>updates the entries in \(A[i..j]\) by adding \(v\).</em></p> <p>In this solution, we utilize a Fenwick tree on an array \(B[1,n]\), initially populated with zeros. For a <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code>, we add \(v\) to \(B[l]\) and subtract \(v\) from \(B[r+1]\). This ensures that the value at position \(i\) is the prefix sum up to \(B[i]\).</p> <p>A Rust implementation of this solution is the following.</p> <pre><code class="language-Rust">#[derive(Debug)]
struct UpdateArray {
    ft: FenwickTree,
}

impl UpdateArray {
    pub fn with_len(n: usize) -&gt; Self {
        Self {
            ft: FenwickTree::with_len(n),
        }
    }

    pub fn len(&amp;self) -&gt; usize {
        self.ft.len()
    }

    pub fn access(&amp;self, i: usize) -&gt; i64 {
        self.ft.sum(i)
    }

    pub fn range_update(&amp;mut self, l: usize, r: usize, v: i64) {
        assert!(l &lt;= r);
        assert!(r &lt; self.ft.len());

        self.ft.add(l, v);
        if r + 1 &lt; self.ft.len() {
            self.ft.add(r + 1, -v);
        }
    }
}
</code></pre> <p><br></p> <h4 id="dynamic-prefix-sums-with-range-update">Dynamic Prefix-sums with Range Update</h4> <p>The range update of the previous problem is paired with the <code class="language-plaintext highlighter-rouge">access(i)</code> operation. This is easier than the problem we are going to solve in this section. Here we want to support <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code> and <code class="language-plaintext highlighter-rouge">sum(i)</code> operations. Notice that <code class="language-plaintext highlighter-rouge">access(i)</code> is also immediately supported with <code class="language-plaintext highlighter-rouge">sum(i)</code> - <code class="language-plaintext highlighter-rouge">sum(i-1)</code>. This pair of operations makes the problem harder than the previous one.</p> <p>More formally, the problem is as follow.</p> <p><em>Given an array \(A[1,n]\) of integers, we would like to support the following operations.</em></p> <ul> <li> <code class="language-plaintext highlighter-rouge">sum(i)</code> <em>returns \(\sum_{k=1}^i A[k]\);</em> </li> <li> <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code> <em>updates the entries in \(A[l..r]\) by adding \(v\).</em> </li> </ul> <p>We notice that the <code class="language-plaintext highlighter-rouge">add</code> operation of the original Fenwick tree is just a special case of the <code class="language-plaintext highlighter-rouge">range_update</code> operation. Moreover, as mentioned above, <code class="language-plaintext highlighter-rouge">access(i)</code> operation is also supported with two <code class="language-plaintext highlighter-rouge">sum</code> operations.</p> <p>It’s evident that we can solve a <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code> with \(j-i+1\) <code class="language-plaintext highlighter-rouge">add</code> queries in \(\Theta((j-i+1)\log n)\) time. However, our goal is to achieve a time complexity of \(\Theta(\log n)\). This time complexity is independent of the size of the updated range and, therefore, is much more better than the previous one for large ranges.</p> <p>The solution to this problem utilizes two Fenwick trees. Therefore, we require doubling the space usage to support the more powerful <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code> operation.</p> <p>Initially, we consider a flawed solution using a single Fenwick tree, denoted as \(FT_1\). To fix the issues in this solution, we introduce a second Fenwick tree, denoted as \(FT_2\).</p> <p>In our initial approach, we follow a similar strategy to the one used in the <em>‘Update the Array’</em> problem. For a <code class="language-plaintext highlighter-rouge">range_update(r, l, v)</code>, we modify \(FT_1\) by adding \(v\) at position \(l\) and subtracting \(v\) at position \(r+1\). When querying <code class="language-plaintext highlighter-rouge">sum(i)</code>, we multiply the result from \(FT_1\) by \(i\). This approach, however, led to errors in the results.</p> <p>Let’s consider a <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code> operation on an brand new Fenwick tree. The correct results for a query <code class="language-plaintext highlighter-rouge">sum(i)</code> after the update are the following.</p> <ul> <li>If \(1 \leq i &lt; l\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \(0\).</li> <li>If \(l \leq i &lt; r\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \(v(i-l+1)\).</li> <li>If \(r \leq i\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \(v(r-l+1)\).</li> </ul> <p>Instead, the results returned by our implementation of <code class="language-plaintext highlighter-rouge">sum(i)</code> are the following.</p> <ul> <li>If \(1 \leq i &lt; l\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \(0\);</li> <li>If \(l \leq i &lt; r\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \(v\cdot i = v (l-1) + v(i-l+1)\);</li> <li>If \(r &lt; i\), <code class="language-plaintext highlighter-rouge">sum(i)</code> is \((v-v)i = 0\).</li> </ul> <p>Our initial implementation reports the correct results for \(1 \leq i &lt; l\) but introduces errors in other cases. Specifically, for \(l\leq i \leq r\), it includes an additional term \(v(l-1)\), while it erroneously reports \(0\) instead of the correct value \(v(r-l+1)\) in the latter case.</p> <p>To address these errors, we introduce a second Fenwick tree, denoted as \(FT_2\), which will keep track of these discrepancies. When we perform a <code class="language-plaintext highlighter-rouge">range_update(l, r, v)</code>, we add \(-v(l-1)\) to position \(l\) and \(v\cdot r\) to position \(r+1\) in \(FT_2\).</p> <p>This revised approach ensures that the result of <code class="language-plaintext highlighter-rouge">sum(i)</code> can be expressed as \(a\cdot i + b\), where \(a\) represents the sum up to \(i\) in \(FT_1\) and \(b\) is the sum up to \(i\) in \(FT_2\).</p> <p>The value of \(b\) from the second Fenwick tree corrects the errors present in the flawed solution. Specifically:</p> <ul> <li>For \(1 \leq i &lt; l\), \(b\) equals \(0\).</li> <li>For \(l \leq i \leq r\), \(b\) equals \(-v(l-1)\).</li> <li>For \(r &lt; i\), \(b\) is \(v\cdot r - v(l-1) = v(r-l+1)\).</li> </ul> <p>The Rust implementation of Fenwick tree with range update is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">RangeUpdate</span> <span class="p">{</span>
    <span class="n">ft1</span><span class="p">:</span> <span class="n">FenwickTree</span><span class="p">,</span>
    <span class="n">ft2</span><span class="p">:</span> <span class="n">FenwickTree</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RangeUpdate</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_len</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">ft1</span><span class="p">:</span> <span class="nn">FenwickTree</span><span class="p">::</span><span class="nf">with_len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
            <span class="n">ft2</span><span class="p">:</span> <span class="nn">FenwickTree</span><span class="p">::</span><span class="nf">with_len</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ft1</span><span class="nf">.len</span><span class="p">()</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ft1</span><span class="nf">.sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">i64</span> <span class="o">+</span> <span class="k">self</span><span class="py">.ft2</span><span class="nf">.sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">access</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.sum</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">-</span> <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="k">self</span><span class="nf">.sum</span><span class="p">(</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="nf">.range_update</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">range_update</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">r</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.ft1</span><span class="nf">.add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>

        <span class="k">self</span><span class="py">.ft2</span><span class="nf">.add</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span> <span class="o">*</span> <span class="p">(</span><span class="n">l</span> <span class="k">as</span> <span class="nb">i64</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

        <span class="k">if</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="k">self</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.ft1</span><span class="nf">.add</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">v</span><span class="p">);</span>
            <span class="k">self</span><span class="py">.ft2</span><span class="nf">.add</span><span class="p">(</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span> <span class="o">*</span> <span class="n">r</span> <span class="k">as</span> <span class="nb">i64</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h4 id="further-readings">Further Readings</h4> <ul> <li> <a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917" rel="external nofollow noopener" target="_blank"><em>A New Data Structure for Cumulative Frequency Tables</em></a>, Peter M. Fenwick, Software: Practice and Experience, 1994</li> <li><a href="https://www.youtube.com/watch?v=CWDQJGaN1gY&amp;ab_channel=TusharRoy-CodingMadeSimple" rel="external nofollow noopener" target="_blank">Video tutorial</a></li> <li><a href="https://www.youtube.com/watch?v=kPaJfAUwViY&amp;ab_channel=AlgorithmsLive%21" rel="external nofollow noopener" target="_blank">Another video tutorial</a></li> <li><a href="https://visualgo.net/en/fenwicktree?slide=1" rel="external nofollow noopener" target="_blank">Fenwick Tree at Visualgo</a></li> <li> <a href="http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf" rel="external nofollow noopener" target="_blank">Range Minimum Query with Fenwick Tree</a> and <a href="https://codeforces.com/blog/entry/15169" rel="external nofollow noopener" target="_blank">here</a> </li> <li> <a href="/rossano/assets/pdf/papers/SPE21.pdf"><em>Practical trade-offs for the prefix-sum problem</em></a>, G.E. Pibiri and R. Venturini, Journal of Software: Practice and Experience (SPE), 2021</li> </ul> <p><br></p> <h4 id="exercises">Exercises</h4> <ul> <li><a href="https://codeforces.com/gym/100741/problem/A" rel="external nofollow noopener" target="_blank">Queries</a></li> <li><a href="https://codeforces.com/contest/1354/problem/D" rel="external nofollow noopener" target="_blank">Multiset</a></li> <li><a href="http://codeforces.com/problemset/problem/459/D?locale=en" rel="external nofollow noopener" target="_blank">Pashmak and Parmida’s problem</a></li> <li><a href="https://codeforces.com/contest/369/problem/E" rel="external nofollow noopener" target="_blank">Valera and Queries</a></li> </ul> <p>These notes are for the <a href="/rossano/competitive/"><em>“Competitive Programming and Contests”</em></a> course at Università di Pisa.</p> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>For an introduction to (static) prefix sums and their applications, take a look at <a href="/rossano/blog/2023/prefixsums"><em>‘The Power of Prefix Sums’</em></a> post. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">↩</a></p> </li> </ol> </div> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/mosalgorithm/">Mo's Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/prefixsums/">The Power of Prefix Sums</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/sweepline/">Sweep Line Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson12324/">Tree Traversals in Rust</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/binarysearch/">Applications of Binary Search</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"rossanoventurini/webpage","data-repo-id":"R_kgDOKRTPSw","data-category":"General","data-category-id":"DIC_kwDOKRTPS84CZ7tz","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Rossano Venturini. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/rossano/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/rossano/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/rossano/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/rossano/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/rossano/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRWXE6TB2L"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LRWXE6TB2L");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"e35e6134ceef91b419bad00adc81df84"});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>