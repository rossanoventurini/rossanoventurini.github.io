<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="E0vDQCYLRDz-hSNBg2blH7KJpNUSxElnYzNlfGC_xjo"> <meta name="msvalidate.01" content="AB84189524C3D3ACAE3EA77DC5F97F11"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Mo's Algorithm | Rossano Venturini</title> <meta name="author" content="Rossano Venturini"> <meta name="description" content="The Mo's Algorithm is a powerful and efficient technique for solving a wide variety of range query problems. It becomes particularly useful for kind of queries where the use of a Segment Tree or similar data structures is not feasible."> <meta name="keywords" content="algorithm, data-structures, rust, efficiency"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/rossano/assets/img/favicon.png"> <link rel="stylesheet" href="/rossano/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pages.di.unipi.it/rossano/blog/2023/mosalgorithm/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/rossano/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/rossano/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/rossano/">Rossano Venturini</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/rossano/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/rossano/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/rossano/publications/">Publications</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/rossano/competitive/">Competitive Programming and Contests</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/rossano/courses/">Teaching activity</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Mo's Algorithm</h1> <p class="post-meta">October 31, 2023</p> <p class="post-tags"> <a href="/rossano/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/rossano/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust,</a>   <a href="/rossano/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms,</a>   <a href="/rossano/blog/tag/data-structures"> <i class="fas fa-hashtag fa-sm"></i> data-structures</a>     ·   <a href="/rossano/blog/category/notes"> <i class="fas fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The <em>Mo’s Algorithm</em> is a powerful and efficient technique for solving a wide variety of range query problems. It becomes particularly useful for kind of queries where the use of a Segment Tree or similar data structures is not feasible. This typically occurs when the query is non-associative, meaning that the result of a query on a range cannot be derived by combining the answers of the subranges that cover the original range.</p> <p>Mo’s algorithm tipically achieves a time complexity of \(O((n+q)\sqrt{n})\), where \(n\) represents the size of the dataset, and \(q\) is the number of queries.</p> <p><br></p> <h4 id="a-difficult-problem">A Difficult Problem</h4> <p>Let’s consider the following problem.</p> <p><em>We are given an array \(A[1, n]\) of integers and our goal is to solve \(q\) queries <code class="language-plaintext highlighter-rouge">power</code>. For a query <code class="language-plaintext highlighter-rouge">power(l,r)</code> we have to compute the “power” of the subarray \(A[l, r]\). For each integer \(s\) within this subarray, let \(K_s\) represent the number of occurrences. The subarray’s power is defined as the sum of the products \(s \cdot K_s \cdot K_s\) for every positive integer \(s\) that appears in the subarray.</em></p> <p>Our goal is to achieve a time complexity of \(\Theta((n+q)\sqrt{n})\) to solve all the \(q\) queries. This may appear quite challenging, and you might even wondering where the factor \(\sqrt{n}\) is coming from.</p> <p>For now, let’s temporarily set aside the current problem and begin by introducing the Mo’s algorithm with a simpler one. By the end of these notes, you’ll be astonished at how straightforward this problem becomes with the right algorithmic tool.</p> <p><br></p> <h4 id="a-easier-problem">A Easier Problem</h4> <p>For many types of range queries, such as <code class="language-plaintext highlighter-rouge">RangeSum</code>, <code class="language-plaintext highlighter-rouge">RMQ</code>, <code class="language-plaintext highlighter-rouge">Distinct</code>, and others, there exist suitable data structures (like the Segment Tree) to answer queries efficiently and online. Solving a query online means that the data structure answers the query as soon as it is presented, without any delay. However, for some more complex query types, there doesn’t exist such online-efficient data structures.</p> <p>For certain query types, the best we can hope for is an efficient solution that works effectively only when handling a sufficiently large batch of queries. This way, the solution can process the queries in the order it deems most favorable. With such solutions, the time complexity of an individual query is low only in an amortized sense.</p> <p>The Mo’s algorithm is one of these strategies: if the batch consists of \(q = \Omega(n)\) queries, each query can be solved in \(\Theta(\sqrt{n})\) amortized time.</p> <p>Consider now the following problem.</p> <p><em>We are given an array \(A[0,n-1]\) consisting of colors, with each color represented by an integer within \([0, n-1]\). Additionally, we are given a set of \(q\) range queries called <code class="language-plaintext highlighter-rouge">three_or_more</code>. The query <code class="language-plaintext highlighter-rouge">three_or_more(l, r)</code> aims to count the colors that occur at least three times within the subarray \(A[l, r]\).</em></p> <p>Let’s begin by examining a straightforward algorithm that addresses a query <code class="language-plaintext highlighter-rouge">three_or_more(l, r)</code> by scanning the subarray \(A[l, r]\). The algorithm maintains an array of <code class="language-plaintext highlighter-rouge">counters</code> to track the number of occurrences of each color within the query range. Whenever a color reaches three occurrences, the <code class="language-plaintext highlighter-rouge">answer</code> is incremented by one.</p> <p>Below is a Rust implementation of this strategy.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">three_or_more_slow</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">queries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">counters</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">answers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">queries</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">in</span> <span class="n">queries</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">answer</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="o">..=</span><span class="n">r</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">ans</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">color</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">counters</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">counters</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
                <span class="n">ans</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">ans</span>
            <span class="p">}</span>
        <span class="p">});</span>

        <span class="n">answers</span><span class="nf">.push</span><span class="p">(</span><span class="n">answer</span><span class="p">);</span>

        <span class="n">a</span><span class="p">[</span><span class="n">l</span><span class="o">..=</span><span class="n">r</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.for_each</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">color</span><span class="p">|</span> <span class="n">counters</span><span class="p">[</span><span class="n">color</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">answers</span>
<span class="p">}</span>
</code></pre></div></div> <p>Observe that, after each query, it’s essential to reset the vector of counters. In the above implementation, this reset is done using the code snippet <code class="language-plaintext highlighter-rouge">a[l..=r].iter().for_each(|&amp;color| counters[color] = 0)</code>. What’s noteworthy is that this method selectively resets only the counters associated with colors within the queried subarray. This approach ensures that the time spent on resetting is proportional to the size of the queried range, rather than the length of <code class="language-plaintext highlighter-rouge">counters</code>. Consequently, this gives a better running time when dealing with short queried subarrays. However, this minor optimization doesn’t change the worst-case time complexity: <em>the algorithm is very slooooooow</em>.</p> <p>Indeed, it’s evident that it has a time complexity of \(\Theta(qn)\). The figure below illustrates an input that showcases the worst-case running time. We have \(n\) queries. The first query range has a length of \(n\) and spans the entire array. Then, the subsequent query ranges are each one unit shorter, until the last one, which has a length of one. The total length of these ranges is \(\Theta(n^2)\), which is also the time complexity of the solution.</p> <div class="row mt-1"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/mos/Mos_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p><br></p> <h4 id="mos-algorithm">Mo’s algorithm</h4> <p>Let’s now introduce a different way to implementing the inefficent algorithm above. At first glance, this may appear to be just a more convoluted way of implementing the same strategy, seemingly offering no advantage in terms of worst-case running time. However, as we will see later on, we can achieve a significantly improved time complexity just by strategically rearranging the queries.</p> <p>Suppose we have just answered the query for the range \([l', r']\) and are now addressing the query for the range \([l, r]\). Instead of starting from scratch, we can update the previous answer and counters by adding or removing the contributions of colors that are in the new query range but not in the previous one, or vice versa. Specifically, for the left endpoints, we must remove all the colors in \(A[l', l-1]\) if \(l' &lt; l\), or we need to add all the colors in \(A[l, l'-1]\) if \(l &lt; l'\). The same applies to the right endpoints \(r\) and \(r'\).</p> <p>The Rust implementation below utilizes two closures, <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">remove</code>, to keep <code class="language-plaintext highlighter-rouge">answer</code> and <code class="language-plaintext highlighter-rouge">counters</code> updated as we adjust the endpoints.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">three_or_more</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">queries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">counters</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">answers</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">queries</span><span class="nf">.len</span><span class="p">());</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">cur_r</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// here right endpoint is excluded</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">answer</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">in</span> <span class="n">queries</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">add</span> <span class="o">=</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">counters</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">counters</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">3</span> <span class="p">{</span>
                <span class="n">answer</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">while</span> <span class="n">cur_l</span> <span class="o">&gt;</span> <span class="n">l</span> <span class="p">{</span>
            <span class="n">cur_l</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">add</span><span class="p">(</span><span class="n">cur_l</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="n">cur_r</span> <span class="o">&lt;=</span> <span class="n">r</span> <span class="p">{</span>
            <span class="nf">add</span><span class="p">(</span><span class="n">cur_r</span><span class="p">);</span>
            <span class="n">cur_r</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="k">mut</span> <span class="n">remove</span> <span class="o">=</span> <span class="p">|</span><span class="n">i</span><span class="p">|</span> <span class="p">{</span>
            <span class="n">counters</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="k">if</span> <span class="n">counters</span><span class="p">[</span><span class="n">a</span><span class="p">[</span><span class="n">i</span><span class="p">]]</span> <span class="o">==</span> <span class="mi">2</span> <span class="p">{</span>
                <span class="n">answer</span> <span class="o">-=</span> <span class="mi">1</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">while</span> <span class="n">cur_l</span> <span class="o">&lt;</span> <span class="n">l</span> <span class="p">{</span>
            <span class="nf">remove</span><span class="p">(</span><span class="n">cur_l</span><span class="p">);</span>
            <span class="n">cur_l</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="n">cur_r</span> <span class="o">&gt;</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">cur_r</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="nf">remove</span><span class="p">(</span><span class="n">cur_r</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">answers</span><span class="nf">.push</span><span class="p">(</span><span class="n">answer</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">answers</span>
<span class="p">}</span>
</code></pre></div></div> <p>The time complexity of this algorithm remains \(\Theta(qn)\). However, we observe that a query now executes more quickly if its range significantly overlaps with the range of the previous query.</p> <p>This effect is perfectelly explained by the input of the previosu figure. This is input becomes a best-case for the new implementation as it takes \(\Theta(n)\) time. Indeed, after spending linear time on the first query, any subsequent query is answered in constant time.</p> <p>This implementation is highly sensitive to the ordering of the queries. It is enough to modify the ordering of the above queries, as shown in the figure below, to revert to quadratic time. In the example below, we rearrange the queries to alternate between a long and a short query. With this ordering, the new implementation takes \(\Theta(n^2)\) time.</p> <div class="row mt-1"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/mos/Mos_2.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>These considerations lead to a question: <em>if we have a sufficient number of queries, can we rearrange them in a way that exploits the overlap between successive queries to gain an asymptotic advantage in the overall running time</em>?</p> <p>Mo’s algorithm answers positively this question by providing a reordering of the queries such that the time complexity reduces to \(\Theta((q+n)\sqrt{n})\).</p> <p>The idea is to conceptually partition the array \(A\) into \(\sqrt{n}\) buckets, each with a size of \(\sqrt{n}\), named \(B_1, B_2, \ldots, B_{\sqrt{n}}\). A query belongs to bucket \(B_k\) if and only if its left endpoint \(l\) falls into the \(k\)-th bucket, which can be expressed as \(\lfloor l/\sqrt{n} \rfloor = k\).</p> <p>Initially, we group the queries based on their corresponding buckets, and within each bucket, the queries are solved in ascending order of their right endpoints.</p> <p>The figure shows this bucketing approach and the queries of one bucket sorted by their right endpoints.</p> <div class="row mt-1"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/mos/Mos_3.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Now, let’s analyze the time complexity of the algorithm with this query reordering. It’s sufficient to count the number of times we move the indexes <code class="language-plaintext highlighter-rouge">cur_l</code> and <code class="language-plaintext highlighter-rouge">cur_r</code>. This is because both <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">remove</code> take constant time, and, thus, the time complexity is proportional to the overall number of moves of these two indexes.</p> <p>Let’s concentrate on a specific bucket. As we process the queries in ascending order of their right endpoints, the index <code class="language-plaintext highlighter-rouge">cur_r</code> moves a total of at most \(n\) times. On the other hand, the index <code class="language-plaintext highlighter-rouge">cur_l</code> can both increase and decrease but, it is constrained within the bucket, and, thus, it cannot move more than \(\sqrt{n}\) times per query. Thus, for a bucket with \(b\) queries, the overall time to process its queries is \(\Theta(b\sqrt{n} + n)\).</p> <p>Summing up over all buckets, the time complexity is \(\Theta(q\sqrt{n} + n\sqrt{n})\), which results in \(\Theta(sqrt{n})\) amortized time per query when \(m = \Omega(n)\).</p> <p>Here’s a Rust implementation of the reordering process. We sort the queries by buckets, using their left endpoints, and within the same bucket, we sort them in ascending order of the right endpoints. We also have to compute a <code class="language-plaintext highlighter-rouge">permutation</code> to keep track of how the queries have been reordered. This permutation is essential for returning the answers to their original ordering.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">mos</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">usize</span><span class="p">],</span> <span class="n">queries</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c1">// Sort the queries by bucket and get the permutation induced by this sorting.</span>
    <span class="c1">// The latter is needed to permute the answers back to the original ordering</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sorted_queries</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">queries</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.cloned</span><span class="p">()</span><span class="nf">.collect</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">permutation</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="o">..</span><span class="n">queries</span><span class="nf">.len</span><span class="p">())</span><span class="nf">.collect</span><span class="p">();</span>

    <span class="k">let</span> <span class="n">sqrt_n</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span><span class="nf">.len</span><span class="p">()</span> <span class="k">as</span> <span class="nb">f64</span><span class="p">)</span> <span class="k">as</span> <span class="nb">usize</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">sorted_queries</span><span class="nf">.sort_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)|</span> <span class="p">(</span><span class="n">l</span> <span class="o">/</span> <span class="n">sqrt_n</span><span class="p">,</span> <span class="n">r</span><span class="p">));</span>
    <span class="n">permutation</span><span class="nf">.sort_by_key</span><span class="p">(|</span><span class="o">&amp;</span><span class="n">i</span><span class="p">|</span> <span class="p">(</span><span class="n">queries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.0</span> <span class="o">/</span> <span class="n">sqrt_n</span><span class="p">,</span> <span class="n">queries</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="na">.1</span><span class="p">));</span>

    <span class="k">let</span> <span class="n">answers</span> <span class="o">=</span> <span class="nf">three_or_more</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">sorted_queries</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">permuted_answers</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">answers</span><span class="nf">.len</span><span class="p">()];</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">answer</span><span class="p">)</span> <span class="k">in</span> <span class="n">permutation</span><span class="nf">.into_iter</span><span class="p">()</span><span class="nf">.zip</span><span class="p">(</span><span class="n">answers</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">permuted_answers</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">answer</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">permuted_answers</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h4 id="the-difficult-problem-revisited">The Difficult Problem Revisited</h4> <p>As I promised, the challenging problem introduced above no longer seems that hard. Just use Mo’s algorithm and a little bit of attention in updating the answer after a <code class="language-plaintext highlighter-rouge">add</code> or a <code class="language-plaintext highlighter-rouge">remove</code>.</p> <p><br></p> <h4 id="final-consideration-on-mos-algorithm">Final Consideration on Mo’s Algorithm</h4> <p>Mo’s algorithm is an offline approach, which means we cannot use it when we are constrained to a specific order of queries or when update operations are involved.</p> <p>When implementing Mo’s algorithm, the most challenging aspect is implementing the functions <code class="language-plaintext highlighter-rouge">add</code> and <code class="language-plaintext highlighter-rouge">remove</code>. There are query types for which these operations are not as straightforward as in previous problems and require the use of more advanced data structures than just an array of counters. One of these cases is the range minimum queries (<em>RMQ</em>).</p> <p>For RMQ, the addition and removal of an element needs maintaining the elements in the range within a Min-Heap, which increases the query time by a factor of \(\log n\). Consequently, in this case, the amortized time per query is \(\Theta(\sqrt{n}\log n)\), which is much worse than the ad hoc (and online) solution using a segment tree. This shouldn’t come as a surprise, as ad hoc solutions that leverage specific properties of the problem at hand can often outperform general techniques like Mo’s algorithm.</p> <p>To conclude, let’s consider an exercise that teaches the use of Mo’s algorithm to solve queries on a tree.</p> <p><em>You have a rooted tree consisting of \(n\) vertices. Each vertex of the tree has some color. We will assume that the tree vertices are numbered by integers from \(1\) to \(n\). Then we represent the color of vertex \(v\) as \(c_v\). The tree root is the vertex with number \(1\).</em></p> <p><em>We need to answer \(m\) queries. Each query is described by two integers \(v_j,k_j\). The answer to query \(v_j, k_j\) is the number of colors \(c\) that occur at least \(k_j\) in the subtree of vertex \(v_j\).</em></p> <p>This problem can be solved in \(\Theta((m+n)\sqrt{n})\) time with the Mo’s algorithm. How?</p> <p>We should note that for this problem there exists a more advanced solution which runs in \(\Theta((n+q)\log n)\) time. This solution uses the <a href="https://en.wikipedia.org/wiki/Heavy-light_decomposition" rel="external nofollow noopener" target="_blank">heavy-light decomposition</a> of the tree. How?</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson22324/">HandsOn 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/fenwick/">Dynamic Prefix Sums with Fenwick Tree</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/prefixsums/">The Power of Prefix Sums</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/sweepline/">Sweep Line Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson12324/">Tree Traversals in Rust</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"rossanoventurini/webpage","data-repo-id":"R_kgDOKRTPSw","data-category":"General","data-category-id":"DIC_kwDOKRTPS84CZ7tz","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Rossano Venturini. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/rossano/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/rossano/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/rossano/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/rossano/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/rossano/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRWXE6TB2L"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LRWXE6TB2L");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"e35e6134ceef91b419bad00adc81df84"});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>