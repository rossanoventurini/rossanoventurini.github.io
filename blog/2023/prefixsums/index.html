<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="E0vDQCYLRDz-hSNBg2blH7KJpNUSxElnYzNlfGC_xjo"> <meta name="msvalidate.01" content="AB84189524C3D3ACAE3EA77DC5F97F11"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>The Power of Prefix Sums | Rossano Venturini</title> <meta name="author" content="Rossano Venturini"> <meta name="description" content="Prefix sums offer an elegant and efficient solution to a variety of problems. In this notes, we showcase several such problems and provide their solutions with Rust implementations."> <meta name="keywords" content="algorithm, data-structures, rust, efficiency"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/rossano/assets/img/favicon.png"> <link rel="stylesheet" href="/rossano/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pages.di.unipi.it/rossano/blog/2023/prefixsums/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/rossano/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/rossano/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/rossano/">Rossano Venturini</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/rossano/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/rossano/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/rossano/publications/">Publications</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/rossano/competitive/">Competitive Programming and Contests</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/rossano/courses/">Teaching activity</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">The Power of Prefix Sums</h1> <p class="post-meta">October 10, 2023</p> <p class="post-tags"> <a href="/rossano/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/rossano/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust,</a>   <a href="/rossano/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms,</a>   <a href="/rossano/blog/tag/data-structures"> <i class="fas fa-hashtag fa-sm"></i> data-structures</a>     ·   <a href="/rossano/blog/category/notes"> <i class="fas fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p><em>Prefix sums</em>, also known as cumulative sums or cumulative frequencies, offer an elegant and efficient way to solve a wide range of problems that involve querying cumulative information about a sequence of values or elements.</p> <p>The essence of prefix sums lies in transforming a given array of values into another array, where each element at a given index represents the cumulative sum of all preceding elements in the original array.</p> <p>To be more formal, let’s assume we have an array \(A[1,n]\) of values, and our objective is to support the query <code class="language-plaintext highlighter-rouge">range_sum(i,j)</code>, which returns the sum of the values in the subarray \(A[i..j]\).</p> <p>For example, suppose you have an array \(A[1,8]\) with values: [2, 4, 1, 7, 3, 0, 4, 2]. The query <code class="language-plaintext highlighter-rouge">range_sum(2, 6)</code> equals \(4+1+7+3+0 = 15\).</p> <p>These queries can be solved in constant time by maintaining the prefix sum array. This array \(P[1,n]\) stores, at any position \(i\), the sum of the values in \(A\) up to the \(i\)th position. In other words, \(P[i] = \sum_{k=1}^i A[k]\).</p> <p>The arrays \(A\) and \(P\) are shown in the figure below.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/prefixsums/Prefixsums_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Armed with \(P\), a <code class="language-plaintext highlighter-rouge">range_sum(i,j)</code> query is resolved by calculating \(P[j]-P[i-1]\).</p> <p>Continuing the example shown in the figure above, <code class="language-plaintext highlighter-rouge">range_sum(2, 6)</code> is \(P[6] - P[1] = 17 - 2 = 15\).</p> <p><br></p> <h4 id="prefix-sums-in-rust">Prefix Sums in Rust</h4> <p>In Rust, the combinator <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">scan</code></a> can produce the prefix sums (and much more) from an iterator.</p> <p><code class="language-plaintext highlighter-rouge">scan</code> is an iterator adapter that bears similarity to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold" rel="external nofollow noopener" target="_blank">fold</a>. Similar to <code class="language-plaintext highlighter-rouge">fold</code>, <code class="language-plaintext highlighter-rouge">scan</code> maintains an internal state, initially set to a seed value, which is modified by a closure taking both the current internal state and the current element from the iterator into account.</p> <p>The distinction between <code class="language-plaintext highlighter-rouge">scan</code> and <code class="language-plaintext highlighter-rouge">fold</code> is that the former produces a new iterator with all the states taken by its internal state, whereas the latter only returns the value of the final internal state.</p> <p>The following code snippet illustrates how to employ <code class="language-plaintext highlighter-rouge">scan</code> for computing prefix sums.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="k">let</span> <span class="n">psums</span> <span class="o">=</span> <span class="n">a</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
        <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

<span class="nd">assert!</span><span class="p">(</span><span class="n">psums</span><span class="nf">.eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">]));</span>
</code></pre></div></div> <p><br></p> <h4 id="applications-of-prefix-sums">Applications of Prefix Sums</h4> <p>Range sum queries are exceptionally useful for solving a variety of other problems involving other kind of range queries. We present here solutions to three problems from CodeForces, which serve as examples of the power of prefix sums.</p> <p>Below, you’ll find links to these problems if you’d like to attempt them yourself before reading their solutions.</p> <ul> <li><a href="http://codeforces.com/problemset/problem/313/B?locale=en" rel="external nofollow noopener" target="_blank">Ilya and Queries</a></li> <li><a href="http://codeforces.com/problemset/problem/466/C?locale=en" rel="external nofollow noopener" target="_blank">Number of Ways</a></li> <li><a href="http://codeforces.com/problemset/problem/276/C?locale=en" rel="external nofollow noopener" target="_blank">Little Girl and Maximum</a></li> </ul> <p><br></p> <h5 id="ilya-and-queries">Ilya and Queries</h5> <p><em>We have a string \(s=s_1s_2 \ldots s_n\) consisting only of characters \(a\) and \(b\) and we need to answer \(m\) queries.</em></p> <p><em>Each query \(q(l, r)\), where \(1 \leq l &lt; r \leq n\), asks for the number of positions \(i \in [l, r]\) such that \(s_i = s_{i+1}\).</em></p> <p>Let’s consider an example to better illustrate this problem.</p> <p>Given string \(s = aabbbaaba\). Consider the query \(q(3, 6)\). We are interested in the substring \(bbba\). So, the answer for this query is \(2\) because there are three positions followed by the same symbol, namely position \(1\), \(2\), and \(4\) in the substring.</p> <p>The idea is that of computing the binary vector \(B[1,n]\) such that \(B[i]=1\) if \(s_i == s_{i+1}\), \(0\) otherwise. This way, the answer to the query \(q(l,r)\) is \(\sum_{i=l} ^{r-1} B[i]\). Thus, each query can be solved in constant time by computing prefix-sums on vector \(B\).</p> <p>For example, the binary vector \(B\) for the string \(s = aabbbaaba\) is [1, 0, 1, 1, 0, 1, 0, 0, 0]. Its prefix sum array \(P\) is [1, 1, 2, 3, 3, 4, 4, 4, 4]. Therefore, the query \(q(3,6) = P[5]-P[2] = 3-1 = 2\).</p> <p>The Rust implementation is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Ilya</span> <span class="p">{</span>
    <span class="n">psums</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Ilya</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">psums</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nf">.as_bytes</span><span class="p">()</span>
            <span class="nf">.windows</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="mi">1usize</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0usize</span> <span class="p">})</span>
            <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">psums</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Queries use 0-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">q</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.psums</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.psums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">self</span><span class="py">.psums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="little-girl-and-maximum">Little Girl and Maximum</h5> <p><em>We are given an array \(A[1,n]\) and a set \(Q\) of \(q\) queries. Each query is a range sum query \(i,j\) which returns the sum of elements in \(A[i..j]\).</em></p> <p><em>The goal is to permute the elements in \(A\) in order to maximize the sum of the results of the queries in \(Q\).</em></p> <p>The main observation is that if we want to maximize the sum, we have to assign the largest values to the most frequently accessed entries. Thus, the solution consists of sorting both \(A\) by descending values and the indexes of \(A\) by descending frequency of access and pairing them in this order. Therefore, once we have computed the frequencies, the solution takes \(\Theta(n\log n)\) time.</p> <p>Thus, we are left with the problem of computing access frequencies. In other words, we want to compute the array \(F[1,n]\), where \(F[i]\) is the number of times the index \(i\) belongs to a query of \(Q\). Computing this vector by updating every single entry in \(F\) for each query takes \(O(nq)\) and, thus, is clearly infeasible.</p> <p>We require a faster algorithm to compute these frequencies. One possible solution involves using the <a href="blog/2023/sweepline/">sweep line algorithm</a>. Since the queries represent intervals, and calculating the frequencies equates to counting the number of overlapping intervals at each position, we can employ an approach similar to the one used in solving the <em>Maximum Number of Overlapping Intervals</em> problem, as detailed in these <a href="blog/2023/sweepline/">notes</a>.</p> <p>This solution has a time complexity of $\Theta(q\log q)$, due to the comparison-based sorting of interval endpoints. Since the endpoints in our problem have a maximum value of $n$, we can optimize the solution to run in $\Theta(q)$ using counting sort. However, there exists an alternative solution based on prefix sums, which is much simpler to implement.</p> <p>The main idea of this alternative solution is to construct an array \(U[1\ldots n]\) such that its prefix sums are equal to our target array \(F\). Interestingly, we need to modify just two entries of \(U\) to account for a query in \(Q\).</p> <p>Initially, all the entries of \(U\) are set to \(0\). For a query \(\langle l, r \rangle\), we add \(1\) to \(U[l]\) and subtract \(1\) from \(U[r+1]\). This way, the prefix sums are as follows:</p> <ul> <li>Unchanged for indexes less than \(l\).</li> <li>Increased by one for indexes in \([l, r]\).</li> <li>Unchanged for indexes greater than \(r\).</li> </ul> <p>Therefore, the prefix sum of \(U\) up to \(i\) equals \(F[i]\). This algorithm takes \(O(q+n)\) time.</p> <p>Here’s the Rust implemetation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We assumes queries are 0-based indexed</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">little_girl</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i64</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">u</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0i64</span><span class="p">;</span> <span class="n">a</span><span class="nf">.len</span><span class="p">()];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">in</span> <span class="n">q</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">u</span><span class="nf">.len</span><span class="p">());</span>

        <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">u</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">u</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">u</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// we sort both f and a in decreasing order, nothing changes</span>
    <span class="n">f</span><span class="nf">.sort_unstable</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.to_vec</span><span class="p">();</span>
    <span class="n">a_sorted</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">a_sorted</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.zip</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">freq</span><span class="p">)|</span> <span class="n">result</span> <span class="o">+</span> <span class="n">value</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h5 id="number-of-ways">Number of Ways</h5> <p><em>Given an array \(A[1,n]\), count the number of ways to split the array into three contiguous parts so that they have the same sums.</em></p> <p>More formally, you need to find the number of such pairs of indices \(i\) and \(j\) (\(2 \leq i \leq j \leq n-1\)) such that:</p> \[\sum_{k=1}^{i-1} A[k] = \sum_{k=i}^{j} A[j] = \sum_{k=j+1}^n A[k]\] <p>For the solution, let \(S\) be the sum of the values in the array. If \(3\) does not divide \(S\), we conclude that the result is zero. Otherwise, we compute an array \(C\) that stores, at position \(i\), the number of suffixes of \(A[i\ldots n]\) that sum to \(\frac{S}{3}\). Then, we scan \(A\) from left to right to compute the prefix sums. Every time the prefix sum at position \(i\) is \(\frac{S}{3}\), we add \(C[i+2]\) to the result. This is because the part \(A[1..i]\) sums to \(S/3\) and can be combined with any pair of parts of \(A[i+1..n]\) where both parts sums to \(S/3\). Since the values in \(A[i+1..n]\) sum to \(2/3 S\), the number of such pairs is the number of suffixes that sum to \(S/3\) in \(A[i+2..n]\). Indeed, if one of this suffix sums to \(S/3\), say \(A[j..n]\), then we are sure that \(A[i+1, j-1]\) sums to \(S/3\).</p> <p>Here’s a Rust implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">number_of_ways</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sum</span><span class="p">:</span> <span class="nb">i64</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">a</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.rev</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">counter</span><span class="p">,</span> <span class="n">sum</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1usize</span>
            <span class="p">};</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">counter</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">c</span><span class="nf">.reverse</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="n">a</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h4 id="exercises">Exercises</h4> <ul> <li><a href="https://leetcode.com/problems/subarray-sum-equals-k/" rel="external nofollow noopener" target="_blank">Subarray Sum Equals K</a></li> <li><a href="https://leetcode.com/problems/continuous-subarray-sum/" rel="external nofollow noopener" target="_blank">Continuous Subarray Sum</a></li> <li><a href="https://codeforces.com/contest/1398/problem/C" rel="external nofollow noopener" target="_blank">Good Subarrays</a></li> <li><a href="https://codeforces.com/contest/1826/problem/D" rel="external nofollow noopener" target="_blank">Running Miles</a></li> </ul> <p>These notes are for the <a href="/rossano/competitive/"><em>“Competitive Programming and Contests”</em></a> course at Università di Pisa.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson32324/">HandsOn 3</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson22324/">HandsOn 2</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/mosalgorithm/">Mo's Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/fenwick/">Dynamic Prefix Sums with Fenwick Tree</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/sweepline/">Sweep Line Algorithm</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"rossanoventurini/webpage","data-repo-id":"R_kgDOKRTPSw","data-category":"General","data-category-id":"DIC_kwDOKRTPS84CZ7tz","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Rossano Venturini. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/rossano/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/rossano/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/rossano/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/rossano/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/rossano/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRWXE6TB2L"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LRWXE6TB2L");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"e35e6134ceef91b419bad00adc81df84"});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>