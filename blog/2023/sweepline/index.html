<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta name="google-site-verification" content="E0vDQCYLRDz-hSNBg2blH7KJpNUSxElnYzNlfGC_xjo"> <meta name="msvalidate.01" content="AB84189524C3D3ACAE3EA77DC5F97F11"> <meta http-equiv="Permissions-Policy" content="interest-cohort=()"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>Sweep Line Algorithm | Rossano Venturini</title> <meta name="author" content="Rossano Venturini"> <meta name="description" content="The Sweep Line Algorithm is a powerful paradigm for solving a variety of problems in computational geometry. In these notes, we employ it to address problems both on a line and in a plane, providing Rust implementations for their solutions."> <meta name="keywords" content="algorithm, data-structures, rust, efficiency"> <link href="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha256-DF7Zhf293AJxJNTmh5zhoYYIMs2oXitRfBjY+9L//AY=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css" integrity="sha256-HtsXJanqjKTc8vVQjO4YMhiqFoXkfBsjBWcX91T1jr8=" crossorigin="anonymous"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/academicons@1.9.1/css/academicons.min.css" integrity="sha256-i1+4qU2G2860dGGIOJscdC30s9beBXjFfzjWLjBRsBg=" crossorigin="anonymous"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/github.css" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="/rossano/assets/img/favicon.png"> <link rel="stylesheet" href="/rossano/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://pages.di.unipi.it/rossano/blog/2023/sweepline/"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jwarby/jekyll-pygments-themes@master/native.css" media="none" id="highlight_theme_dark"> <script src="/rossano/assets/js/theme.js?96d6b3e1c3604aca8b6134c7afdd5db6"></script> <script src="/rossano/assets/js/dark_mode.js?9b17307bb950ffa2e34be0227f53558f"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/rossano/">Rossano Venturini</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/rossano/">About</a> </li> <li class="nav-item active"> <a class="nav-link" href="/rossano/blog/">Notes<span class="sr-only">(current)</span></a> </li> <li class="nav-item "> <a class="nav-link" href="/rossano/publications/">Publications</a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">Teaching</a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item" href="/rossano/competitive/">Competitive Programming and Contests</a> <div class="dropdown-divider"></div> <a class="dropdown-item" href="/rossano/courses/">Teaching activity</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fas fa-moon"></i> <i class="fas fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="post"> <header class="post-header"> <h1 class="post-title">Sweep Line Algorithm</h1> <p class="post-meta">October 9, 2023</p> <p class="post-tags"> <a href="/rossano/blog/2023"> <i class="fas fa-calendar fa-sm"></i> 2023 </a>   ·   <a href="/rossano/blog/tag/rust"> <i class="fas fa-hashtag fa-sm"></i> rust,</a>   <a href="/rossano/blog/tag/algorithms"> <i class="fas fa-hashtag fa-sm"></i> algorithms,</a>   <a href="/rossano/blog/tag/data-structures"> <i class="fas fa-hashtag fa-sm"></i> data-structures</a>     ·   <a href="/rossano/blog/category/notes"> <i class="fas fa-tag fa-sm"></i> notes</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <p>The <em>Sweep Line Algorithm</em> is an algorithmic paradigm used to solve a lot of problems in computational geometry efficiently. The sweep line algorithm can be used to solve problems on a line or on a plane.</p> <p><br></p> <h4 id="maximum-number-of-overlapping-intervals">Maximum Number of Overlapping Intervals</h4> <p>Let’s start the description of this paradigm with a problem on a line.</p> <p><em>We are given a set of \(n\) intervals \([s_i, e_i]\) on a line.</em></p> <p><em>We say that two intervals \([s_i, e_i]\) and \([s_j, e_j]\) overlaps if and only if their intersection is not empty, i.e., if there exist at least a point \(x\) belonging to both intervals.</em></p> <p><em>The goal is to compute the maximum number of overlapping intervals.</em></p> <p>For example, consider the set of intevals in the figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>In this example, we have a set of \(10\) intervals. The maximum number of overlapping intervals is \(5\) (at positions \(3\) and \(4\)).</p> <p>The sweep line algorithm employs an imaginary <em>vertical line</em> sweeping over the x-axis. As it progresses, we maintain a running solution to the problem at hand. The solution is updated when the vertical line reaches certain key points where some <em>event</em> happen. The type of the event tells us how to update the current solution.</p> <p>To apply this paradigm to our problem, we let the sweep line move from left to right and stop at the beginning or the end of the intervals. These are the important points at which an event occurs: new intervals start or end. We also maintain a counter which keeps track of the number of intervals that are currently intersecting the sweep line, along with the maximum value reached by the counter so far. For each point, we first add to the counter the number of intervals that begin at that point, and then we subtract the number of intervals that end at that point.</p> <p>The figure below shows the points touched by the sweep line and the values of the counter.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps_sweep.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Note that the sweep line touches only points on the x-axis where an event occurs. For example, points \(1\) and \(6\) are not taken into consideration. This is important because the number of considered points, and thus the time complexity, is proportional to the number of intervals and not to the size of the x-axis.</p> <p>Here is a Rust implementation. We represent each interesting point as a pair consisting of the point and the kind, which is either <code class="language-plaintext highlighter-rouge">begin</code> or <code class="language-plaintext highlighter-rouge">end</code>. Then, we sort the vector of pairs in increasing order. Finally, we compute every state of the counter and its largest value. The correctness of the solution is based on a specific detail in the sorting step: since <code class="language-plaintext highlighter-rouge">begin</code> is considered smaller than <code class="language-plaintext highlighter-rouge">end</code>, if two points are the same, we first have pairs with <code class="language-plaintext highlighter-rouge">begin</code> and then pairs with <code class="language-plaintext highlighter-rouge">end</code>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">Event</span> <span class="p">{</span>
    <span class="n">Begin</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_overlapping</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.flat_map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)|</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">Begin</span><span class="p">),</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">End</span><span class="p">)])</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">pairs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">pairs</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">kind</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="nn">Event</span><span class="p">::</span><span class="n">Begin</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">counter</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h4 id="closest-pair-of-points">Closest Pair of Points</h4> <p>Let’s tackle a second problem to apply the sweep line paradigm to a two-dimensional problem.</p> <p><em>We are given a set of \(n\) points in the plane.</em></p> <p><em>The goal is to find the closest pair of points in the set. The distance between two points \((x_1, y_1)\) and \((x_2,y_2)\) is the Euclidian distance \(d((x_1,y_1), (x_2,y_2)) = \sqrt{(x_1-x_2)^2 +(y_1-y_2)^2}\).</em></p> <p>A brute force algorithm calculates the distances between all possible pairs of points, resulting in a time complexity of \(\Theta(n^2)\).</p> <p>A faster algorithm employs the sweep line paradigm. We start by sorting the points in increasing order of their x-coordinates. We keep track of the shortest distance, denoted as \(\delta\), seen so far. Initially, \(\delta\) is set to the distance between an arbitrary pair of points.</p> <p>We use a vertical sweep line to iterate through the points, attempting to improve the current shortest distance \(\delta\). Consider the point \(p = (x, y)\) just reached by the vertical sweep line. We can improve \(\delta\) if the closest point <em>to the left</em> of \(p\) has a distance smaller than \(\delta\). If such a point exists, it must have an x-coordinate in the interval \([x - \delta, x]\), as it is to the left of \(p\), and a y-coordinate in the interval \([y - \delta, y + \delta]\).</p> <p>The figure below shows the rectangle within which this point must lie. We have a fact that, at a first glance, may seem quite surprising: <em>there can be at most \(6\) points within the rectangle</em>. The \(6\) circles within the perimeter of the rectangle represent points that are at distance exactly \(\delta\) apart from each other. See the <em>Section 5.4 of Algorithm Design by Kleinberg and Tardos</em> for a proof of this fact.</p> <p>For our purposes, a slightly weaker result is sufficient, which states that <em>the rectangle contains at most \(8\) points</em>.</p> <p>To understand why, consider the \(8\) squares in the figure above. Each of these squares, including its perimeter, can contain at most one point. Assume, for the sake of contradiction, that a square contains two points, denoted as \(q\) and \(q'\). The distance between \(q\) and \(q'\) is smaller than \(\delta\). If point \(q'\) exists, it would have already been processed by the sweep line because it has an x-coordinate smaller than that of \(p\). However, this is not possible, because otherwise the value of \(\delta\) would be smaller than its current value.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/ClosestPair.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"> </picture> </figure> </div> </div> <p>Now that we have the intuition of the solution, let’s add more details. The algorithm maintains a BST with points sorted by their y-coordinates. When we process point \(p=(x,y)\), we iterate over the points with y-coordinates in the interval \([y-\delta, y+\delta]\). If the current point has a \(x\)-coordinate smaller than \(x-\delta\), we remove this point from the set. It will be never useful anymore. Otherwise, we compute its distance with \(p\) and update \(\delta\) if needed. Before moving the sweep line to the next point, we insert \(p\) in the set.</p> <p>What is the complexity of this algorithm? Identifying the range of points with the required y-coordinates takes \(\Theta(\log n)\) time. Iterating over the points in this range takes constant time per point and removing one of them takes \(\Theta(\log n)\) time.</p> <p>How many points do we need to iterate over? There can be at most \(6\) points that have an x-coordinate greater than or equal to \(x-\delta\) and therefore survive. On the other hand, there can be many points with smaller x-coordinates. However, since each point is inserted and subsequently removed from the set at most once during the execution of the algorithm, the cost of dealing with all these points is at most \(\Theta(n \log n)\).</p> <p>The following is a Rust implementation of this algorithm. There are two differences from the above description. First, we compute the squared Euclidean distance. This way, we avoid the computation of the square root, which is slow and results in a floating-point value The second difference is that <strong>we swap the roles of x and y</strong>. Therefore, we process the points by ascending y-coordinate and use a horizontal sweep line. This is easier to implement in Rust. Indeed, with the original approach, we would need to insert points into a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">BTreeSet</code></a> ordered by y-coordinate, which is the second component of the pair. This ordering is not possible with a <code class="language-plaintext highlighter-rouge">BTreeSet</code> unless we create a wrapper for a point that implements the required behavior for a comparison. Instead, if we swap the roles of x and y, the ordering by y is only required during the sorting step, which can be customized using the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort_unstable_by_key" rel="external nofollow noopener" target="_blank"><code class="language-plaintext highlighter-rouge">sort_unstable_by_key</code></a> method.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">distance_squared</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">),</span> <span class="n">q</span><span class="p">:</span> <span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">p</span><span class="na">.0</span> <span class="o">-</span> <span class="n">q</span><span class="na">.0</span><span class="p">)</span><span class="nf">.pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="na">.1</span> <span class="o">-</span> <span class="n">q</span><span class="na">.1</span><span class="p">)</span><span class="nf">.pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nn">Bound</span><span class="p">::</span><span class="n">Included</span><span class="p">;</span>

<span class="c1">// Returns the (squared) Euclidean distance between the closest pair of </span>
<span class="c1">// points in `points`</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">closest_pair</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">points</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">points</span><span class="nf">.sort_unstable_by_key</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="p">(</span><span class="n">p</span><span class="na">.1</span><span class="p">,</span> <span class="n">p</span><span class="na">.0</span><span class="p">));</span> <span class="c1">// sort by y</span>

    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.1</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">points</span><span class="nf">.last</span><span class="p">()</span><span class="o">?</span><span class="na">.1</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">delta</span> <span class="o">=</span> <span class="nf">distance_squared</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span><span class="p">:</span> <span class="n">BTreeSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">point</span> <span class="k">in</span> <span class="n">points</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Search by x and select the points with too small y-coordinate that we remove</span>
        <span class="c1">// to not touch them again in the future</span>
        <span class="k">let</span> <span class="n">to_delete</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">set</span>
            <span class="nf">.range</span><span class="p">((</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)),</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)),</span>
            <span class="p">))</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="n">p</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">&gt;=</span> <span class="n">point</span><span class="na">.0</span><span class="p">)</span>
            <span class="nf">.cloned</span><span class="p">()</span>
            <span class="nf">.collect</span><span class="p">();</span>

        <span class="c1">// Remove those points</span>
        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">to_delete</span> <span class="p">{</span>
            <span class="n">set</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Search again and compute the distances with survived points.</span>
        <span class="c1">// Update delta if needed.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">set</span>
            <span class="nf">.range</span><span class="p">((</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)),</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)),</span>
            <span class="p">))</span>
            <span class="nf">.fold</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">|</span> <span class="n">acc</span><span class="nf">.min</span><span class="p">(</span><span class="nf">distance_squared</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">p</span><span class="p">)));</span>

        <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Some</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br></p> <h4 id="further-readings-and-exercises">Further Readings and Exercises</h4> <ul> <li><a href="https://usaco.guide/plat/sweep-line?lang=cpp" rel="external nofollow noopener" target="_blank">USACO Guide</a></li> <li><a href="https://www.topcoder.com/thrive/articles/Line%20Sweep%20Algorithms" rel="external nofollow noopener" target="_blank">Top Coder</a></li> <li><a href="https://en.wikipedia.org/wiki/Fortune%27s_algorithm" rel="external nofollow noopener" target="_blank">Fortune’s algorithm</a></li> <li><a href="https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/" rel="external nofollow noopener" target="_blank">Check if all the integers in a range are covered</a></li> <li><a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=943" rel="external nofollow noopener" target="_blank">Cow Steeplechase II</a></li> </ul> <p>These notes are for the <a href="/rossano/competitive/"><em>“Competitive Programming and Contests”</em></a> course at Università di Pisa.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/mosalgorithm/">Mo's Algorithm</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/fenwick/">Dynamic Prefix Sums with Fenwick Tree</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/prefixsums/">The Power of Prefix Sums</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/handson12324/">Tree Traversals in Rust</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/rossano/blog/2023/binarysearch/">Applications of Binary Search</a> </li> <div id="giscus_thread" style="max-width: 800px; margin: 0 auto;"> <script>let giscusTheme=localStorage.getItem("theme"),giscusAttributes={src:"https://giscus.app/client.js","data-repo":"rossanoventurini/webpage","data-repo-id":"R_kgDOKRTPSw","data-category":"General","data-category-id":"DIC_kwDOKRTPS84CZ7tz","data-mapping":"title","data-strict":"1","data-reactions-enabled":"1","data-emit-metadata":"0","data-input-position":"bottom","data-theme":giscusTheme,"data-lang":"en",crossorigin:"anonymous",async:""},giscusScript=document.createElement("script");Object.entries(giscusAttributes).forEach(([t,e])=>giscusScript.setAttribute(t,e)),document.getElementById("giscus_thread").appendChild(giscusScript);</script> <noscript>Please enable JavaScript to view the <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments powered by giscus.</a> </noscript> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2023 Rossano Venturini. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.6.1/dist/js/bootstrap.bundle.min.js" integrity="sha256-fgLAgv7fyCGopR/gBNq2iW3ZKIdqIcyshnUULC4vex8=" crossorigin="anonymous"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/rossano/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/rossano/assets/js/zoom.js"></script> <script defer src="https://unpkg.com/bootstrap-table@1.21.4/dist/bootstrap-table.min.js"></script> <script src="/rossano/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/rossano/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/rossano/assets/js/copy_code.js?c9d9dd48933de3831b3ee5ec9c209cac" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script async src="https://www.googletagmanager.com/gtag/js?id=G-LRWXE6TB2L"></script> <script>function gtag(){window.dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-LRWXE6TB2L");</script> <script async src="https://rum.cronitor.io/script.js"></script> <script>window.cronitor=window.cronitor||function(){(window.cronitor.q=window.cronitor.q||[]).push(arguments)},cronitor("config",{clientKey:"e35e6134ceef91b419bad00adc81df84"});</script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>