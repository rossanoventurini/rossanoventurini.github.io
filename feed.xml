<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://pages.di.unipi.it/rossano/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pages.di.unipi.it/rossano/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-10-16T02:12:35+00:00</updated><id>https://pages.di.unipi.it/rossano/feed.xml</id><title type="html">Rossano Venturini</title><subtitle>My personal Web page with notes about algorithms, data structures, low-leve code optimizations, and Rust. </subtitle><entry><title type="html">Dynamic Prefix Sums with Fenwick Tree</title><link href="https://pages.di.unipi.it/rossano/blog/2023/fenwick/" rel="alternate" type="text/html" title="Dynamic Prefix Sums with Fenwick Tree"/><published>2023-10-13T06:01:00+00:00</published><updated>2023-10-13T06:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/fenwick</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/fenwick/"><![CDATA[<p>The <em>Fenwick Tree</em>, also known as the <em>Binary Indexed Tree</em> (BIT), is a popular and elegant data structure that maintains the prefix sums of a dynamic array<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup>. With this data structure we can update values in the original array and still answer prefix sum queries. Both operations runs in logarithmic time.</p> <p>More precisely, the Fenwick tree solves the following problem.</p> <p><em>We have an array \(A[1,n]\) of integers, and we would like to support the following operations:</em></p> <ul> <li><em><code class="language-plaintext highlighter-rouge">sum(i)</code> returns the sum of the elements in \(A[1..i]\);</em></li> <li><em><code class="language-plaintext highlighter-rouge">add(i, v)</code> adds the value \(v\) to the entry \(A[i]\).</em></li> </ul> <p>The Fenwick tree efficiently handles these queries in \(\Theta(\log n)\) time while using linear space. In fact, the Fenwick tree is an <em>implicit</em> data structure, which means it requires only \(O(1)\) additional space in addition to the space needed to store the input data (the array \(A\) in our case).</p> <p>In our descritpion, we are going to use the following array \(A\) as a running example. Notice that we are using a one-based indexing for the array.</p> <div class="row mt-1"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/Array.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <h4 id="two-trivial-solutions">Two Trivial Solutions</h4> <p>Let’s describe two trivial solutions for the problem above.</p> <p>The first solution simply stores \(A\) as it is. This way, <code class="language-plaintext highlighter-rouge">sum(i)</code> is solved by scanning the array in \(\Theta(n)\) time, and <code class="language-plaintext highlighter-rouge">add(i, v)</code> is solved in \(O(1)\) time.</p> <p>The second solution, instead, stores the prefix-sums of \(A\). This way, <code class="language-plaintext highlighter-rouge">sum(i)</code> is solved in \(O(1)\) time, and <code class="language-plaintext highlighter-rouge">add(i, v)</code> is solved by modifying all the entries up to position \(i\) in \(\Theta(n)\) time.</p> <p>The <code class="language-plaintext highlighter-rouge">sum</code>/<code class="language-plaintext highlighter-rouge">add</code> query time tradeoffs of these solutions are clearly unsatisfactory.</p> <p><br/></p> <h3 id="fenwick-tree-level-by-level">Fenwick Tree, Level by Level</h3> <p>The Fenwick Tree provides better tradeoffs for this problem. In our description, we will gradually introduce this data structure by constructing it level by level.</p> <p>To start, let’s simplify the original problem slightly. In this variant, we’ll focus on solving <code class="language-plaintext highlighter-rouge">sum</code> queries only for positions that are powers of \(2\), like positions \(1\), \(2\), \(4\), and \(8\) in our array \(A\). The solution of this variant will be the first level of our Fenwick Tree.</p> <p>The idea for solving this relaxed variant is to sparsify the second trivial solution above, storing only the prefix sums of positions that we need for queries. The figure below illustrates this solution as a tree, with a fictitious root node named \(0\) and child nodes named \(1\), \(2\), \(4\), and \(8\), each storing the sum up to the corresponding power of \(2\). Additionally, below every node, we provide the range of positions it covers. For instance, node \(4\) covers positions in the range \([1, 4]\).</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>We address the queries of the simplified problem as follows:</p> <ul> <li> <p>The <code class="language-plaintext highlighter-rouge">sum(i)</code> query is straightforward. We simply access node \(i\). Of course, this only works for indexes \(i\) that are a power of \(2\).</p> </li> <li> <p>For the <code class="language-plaintext highlighter-rouge">add(i, v)</code> query we need to add \(v\) to all nodes covering ranges that include position \(i\). For example, for the query <code class="language-plaintext highlighter-rouge">add(3, 10)</code>, we add the value \(10\) to nodes \(4\) and \(8\). In general, first we have to find the smallest power of \(2\) greater than \(i\), let’s call it \(j\). Then, we add \(v\) to nodes \(j, 2j, 2^2j, 2^3j, \ldots\).</p> </li> </ul> <p>Observe that <code class="language-plaintext highlighter-rouge">sum</code> takes constanti time and <code class="language-plaintext highlighter-rouge">add</code> takes \(\Theta(\log n)\) time. Hooray! We are within our target time complexity. Now, can we extend this solution to support <code class="language-plaintext highlighter-rouge">sum</code> queries on more positions?</p> <p>We observe that we’re not currently supporting queries for positions within the ranges between consecutive powers of \(2\). For instance, positions in the range \([5,7]\), which fall between \(2^2\) and \(2^3\). But wait! Enabling queries for this subarray is just a smaller instance of our original problem. Therefore, we can apply the same strategy by adding a new level to our tree. If the subarray is \(A[l..r]\), the new level will support the <code class="language-plaintext highlighter-rouge">sum(i)</code> query for any \(i\) such that \(i-l+1\) is a power of \(2\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_2.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Our two-level tree can now handle <code class="language-plaintext highlighter-rouge">sum(i)</code> queries also for positions that are the sum of two powers of \(2\). Why? Consider a position \(i\) expressed as \(2^{k'}+2^{k}\), where \(k'&gt;k\). We can decompose the range \([1,i]\) into two subranges: \([1,2^{k'}]\) and \([2^{k'}+1,2^{k'}+2^{k}=i]\). Both of these subranges are covered by nodes in our tree. Specifically, range \([1,2^{k'}]\) is covered by node \(2^{k'}\) at the first level, while \([2^{k'}+1,2^{k'}+2^{k}=i]\) is covered by node \(i\) at the second level.</p> <p>For example, let’s consider the query <code class="language-plaintext highlighter-rouge">sum(5)</code>. We can handle this in our two-level tree because \(5=2^2+2^0\). Consequently, the range \([1,5]\) is divided into \([1,4]\) and \([5,5]\), and the result (which is \(6\)) is obtained by summing the values of nodes \(2^2=4\) and \(2^2+2^0=5\).</p> <p>Which positions are still not supported for <code class="language-plaintext highlighter-rouge">sum</code> queries? Positions that are neither powers of \(2\) nor the sum of two powers of \(2\). In our example, with \(n=8\), only position \(7=2^2+2^1+2^0\) falls into this category. So, what do we do next? We add a new level to our tree to support queries for positions that are the sum of three powers of \(2\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_level_3.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>That’s all. This is the Fenwick tree for the array \(A\). Now, let’s make some observations:</p> <ol> <li>While we’ve represented our solution as a tree, it can also be represented as an array \(FT\) of size \(n+1\), as shown in the figure above.</li> <li>We no longer require the original array \(A\) because any of its entries \(A[i]\) can be obtained as \(A[i] = \text{sum}(i) - \text{sum}(i-1)\). This is why the Fewniwck tree is an <em>implicit</em> data structure.</li> <li>Let be \(h\) equal to \(\lfloor \log (n) + 1 \rfloor\), which is the length of the binary representation of any position in the range \([1,n]\). Since any position can be expressed as the sum of at most \(h\) powers of \(2\), the tree has no more than \(h\) levels. In fact, the number of levels is either \(h\) or \(h-1\), depending on the value of \(n\).</li> </ol> <p>Now, let’s delve into the details of how to solve our <code class="language-plaintext highlighter-rouge">sum</code> and <code class="language-plaintext highlighter-rouge">add</code> queries on a Fenwick tree.</p> <p><br/></p> <h4 id="answering-a-sum-query">Answering a <code class="language-plaintext highlighter-rouge">sum</code> query</h4> <p>Let’s start by discussing the <code class="language-plaintext highlighter-rouge">sum(i)</code> query. Based on the previous discussion, solving this query involves beginning at node \(i\) and traversing up the tree to reach node \(0\). Thus, <code class="language-plaintext highlighter-rouge">sum</code> takes time proportional to the height of the tree, resulting in a time complexity of \(\Theta(\log n)\).</p> <p>For a running example, let’s take the case where \(i=7\). We start at node $7$ and move to its parent (node $6$), its grandparent (node $4$), and stop at its great-grandparent (the fictitious node $0$), summing their values along the way. This works because the ranges of these nodes (\([1,4]\), \([5,6]\), and \([7,7]\)) collectively cover the queried range \([1,7]\).</p> <p>It’s important to note that answering a <code class="language-plaintext highlighter-rouge">sum</code> query becomes straightforward if we were allowed to store the tree’s structure. However, a significant part of the Fenwick tree’s elegance lies in the fact that storing the tree is not actually necessary. This is because we can efficiently navigate from a node to its parent using a few bit-tricks. This is the reason why the Fenwick tree is also referred to as the Binary Indexed Tree.</p> <p><br/></p> <h5 id="compute-the-parent-of-a-node">Compute the Parent of a Node</h5> <p>We want to compute the <code class="language-plaintext highlighter-rouge">parent</code> of a node, and we want to do it quickly and without representing the structure of the tree.</p> <p>Let’s examine the binary representations of the IDs of the nodes involved in answering the previous query.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Can you find out any pattern? Surprisingly, the binary representation of a node’s parent can be obtained by removing the trailing one (i.e., rightmost bit set to <tt>1</tt>) from the binary representation of its children.</p> <p>Let’s explore why this method works.</p> <p>Suppose we have a node \(i\), and its range is \([j,i]\) for some \(j\). Its children will be nodes \(i+2^0\), \(i+2^1\), \(i+2^2\), and so on, spanning ranges \([j+1, i+2^0]\), \([j+1, i+2^1]\), \([j+1, i+2^2]\), and so forth. The binary representation of any of these children is identical to that of \(i\), except for the addition of the trailing one (due to the term \(2^k\)).</p> <p>Now, we need a clever bit-trick to efficiently obtain the parent of a node. Based on our previous discussion, it’s evident that we need a way to remove the trailing one from the binary representation of a node \(i\). The trailing one can be isolated by computing \(k = i {\tt \&amp;} -i\). Thus, \(i-k\) is the parent of \(i\).</p> <p>In fact, negative numbers are represented in <a href="https://en.wikipedia.org/wiki/Two%27s_complement">two’s complement</a> form. In this representation, the two’s complement of a number is obtained by taking the bitwise complement of the number and then adding one to it.</p> <p>For instance, if we have the binary number \(7\) as <tt>0111</tt>, its two’s complement, which represents \(-7\), is <tt>1001</tt>.</p> <p>The key property of the two’s complement is that it inverts all the bits in the binary representation of a number, except for the leftmost “trailing one. Thus, when we compute the logical AND of a number and its two’s complement, only the trailing one survives. Therefore, the final subtraction \(i-k\) effectively cancels out this bit from \(i\), as required.</p> <p>For example,</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_2.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p><br/></p> <h4 id="performing-an-add">Performing an <code class="language-plaintext highlighter-rouge">add</code></h4> <p>Now, let’s consider the operation <code class="language-plaintext highlighter-rouge">add(i, v)</code>. We need to add the value of <code class="language-plaintext highlighter-rouge">v</code> to each node whose range include the position \(i\).</p> <p>Certainly, node \(i\) is one of these nodes since its range ends at \(i\). Additionally, the right siblings of node \(i\) also encompass the position \(i\) in their ranges. This is because siblings share the same starting position, and right siblings have increasing sizes. The right siblings of the parent of node \(i\), the right siblings of the grandparent, and so on also contain position \(i\).</p> <p>It might seem like we have to modify a large number of nodes. However, a simple observation reveals that this number is at most \(\log n\). This is because, each time we move from a node to its right sibling or to the right sibling of its parent, the size of the covered range at least doubles. And a range cannot double more than \(\log n\) times.</p> <p>The figure below shows in red the nodes to modify for teh operation <code class="language-plaintext highlighter-rouge">add(5, _)</code>.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_add.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Now that we know which are the nodes to modify for <code class="language-plaintext highlighter-rouge">add(i,_)</code>, let’s discuss how to compute these nodes with bit-tricks.</p> <p>Coninuing the above example, starting from \(i=5\), the next node to modify is its right sibling, node \(6\). Let’s take a closer look at their binary representations.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_3.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Can you find out any pattern?</p> <p>It seems that we need to isolate the trailing one in \(5\), which is <tt>0001</tt>, and add it to \(5\) to obtain \(6\). Is this always the correct approach?</p> <p>Let’s try it with another node. The right sibling of the parent of \(6\) (and, therefore, of \(5\)) is \(8\).</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/fenwick/FT_bin_4.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>The trailing one in \(6\) is <tt>0010</tt> (i.e., \(2\)) and \(6+2=8\). Cool!</p> <p>Why is this method correct? The binary representation of a node and its siblings matches, except for the position of the trailing one. When we move from a node to its right sibling, this trailing one shifts one position to the left. Adding this trailing one to a node accomplishes the required shift, as seen when we add \(5\) to its trailing one.</p> <p>Now, consider the ID of a node that is the last child of its parent. In this case, the rightmost and second trailing one are adjacent. To obtain the right sibling of its parent, we need to remove the trailing one and shift the second trailing one one position to the left.</p> <p>Thankfully, this effect is one again achieved by adding the trailing one to the node’s ID.</p> <p>The time complexity of <code class="language-plaintext highlighter-rouge">add</code> query is \(\Theta(\log n)\), as we observe that each time we move to the right sibling of the current node or the right sibling of its parent, the trailing one in its binary representation shifts at least one position to the left. This can occur at most \(\lfloor \log n \rfloor +1\) times.</p> <p><br/></p> <h4 id="fenwick-tree-in-rust">Fenwick Tree in Rust</h4> <p>Here, we present a minimal Rust implementation of a Fenwick tree. In this non-generic implementation, we’ve arbitrarily chosen to use <code class="language-plaintext highlighter-rouge">i64</code> as the type for the values. While we’ve transitioned to 0-based indexing for queries, internally, we still use the 1-based indexing to maintain consistency with the notes.</p> <p>For a more advanced implementation, it could be required to allow generic types and move away from the 1-based indexing. Additionally, there are various potential optimizations to enhance its performance. For more details, refer to <a href="/rossano/assets/pdf/papers/SPE21.pdf"><em>Practical trade-offs for the prefix-sum problem</em></a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">struct</span> <span class="n">FenwickTree</span> <span class="p">{</span>
    <span class="n">tree</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">FenwickTree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_len</span><span class="p">(</span><span class="n">n</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">tree</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0</span><span class="p">;</span> <span class="n">n</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">len</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="p">}</span>

    <span class="cd">/// Indexing is 0-based, even if internally we use 1-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="nb">i64</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> 
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">self</span><span class="py">.tree</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span>
            <span class="n">i</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">next_sibling</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Indexing is 0-based, even if internally we use 1-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">i</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>  

        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.tree</span><span class="nf">.len</span><span class="p">());</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="n">sum</span> <span class="o">+=</span> <span class="k">self</span><span class="py">.tree</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
            <span class="n">i</span> <span class="o">=</span> <span class="k">Self</span><span class="p">::</span><span class="nf">parent</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="n">sum</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">{</span>
            <span class="mi">0</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="nf">.trailing_zeros</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">parent</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">-</span> <span class="k">Self</span><span class="p">::</span><span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="k">fn</span> <span class="nf">next_sibling</span><span class="p">(</span><span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="n">i</span> <span class="o">+</span> <span class="k">Self</span><span class="p">::</span><span class="nf">isolate_trailing_one</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="further-readings">Further Readings</h4> <ul> <li><a href="https://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.14.8917"><em>A New Data Structure for Cumulative Frequency Tables</em></a>, Peter M. Fenwick, Software: Practice and Experience, 1994</li> <li><a href="https://www.youtube.com/watch?v=CWDQJGaN1gY&amp;ab_channel=TusharRoy-CodingMadeSimple">Video description</a></li> <li><a href="https://visualgo.net/en/fenwicktree?slide=1">Fenwick Tree at Visualgo</a></li> <li><a href="http://ioinformatics.org/oi/pdf/v9_2015_39_44.pdf">Range Minimum Query with Fenwick Tree</a> and <a href="https://codeforces.com/blog/entry/15169">here</a></li> <li><a href="/rossano/assets/pdf/papers/SPE21.pdf"><em>Practical trade-offs for the prefix-sum problem</em></a>, G.E. Pibiri and R. Venturini, Journal of Software: Practice and Experience (SPE), 2021</li> </ul> <p><br/></p> <h4 id="exercises">Exercises</h4> <ul> <li><a href="http://www.spoj.com/problems/UPDATEIT/">Update the array</a></li> <li><a href="http://codeforces.com/problemset/problem/652/D?locale=en">Nested segments</a></li> <li><a href="http://codeforces.com/problemset/problem/459/D?locale=en">Pashmak and Parmida’s problem</a></li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p>For an introduction to (static) prefix sums and their applications, take a look at <a href="/rossano/blog/2023/prefixsums"><em>‘The Power of Prefix Sums’</em></a> post. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms,"/><category term="data-structures"/><summary type="html"><![CDATA[The Fenwick Tree, also known as the Binary Indexed Tree (BIT), efficiently manages the prefix sum of an array, even as it undergoes updates. In these notes, we introduce this elegant data structure and describe its Rust implementation.]]></summary></entry><entry><title type="html">The Power of Prefix Sums</title><link href="https://pages.di.unipi.it/rossano/blog/2023/prefixsums/" rel="alternate" type="text/html" title="The Power of Prefix Sums"/><published>2023-10-10T07:01:00+00:00</published><updated>2023-10-10T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/prefixsums</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/prefixsums/"><![CDATA[<p><em>Prefix sums</em>, also known as cumulative sums or cumulative frequencies, offer an elegant and efficient way to solve a wide range of problems that involve querying cumulative information about a sequence of values or elements.</p> <p>The essence of prefix sums lies in transforming a given array of values into another array, where each element at a given index represents the cumulative sum of all preceding elements in the original array.</p> <p>To be more formal, let’s assume we have an array \(A[1,n]\) of values, and our objective is to support the query <code class="language-plaintext highlighter-rouge">range_sum(i,j)</code>, which returns the sum of the values in the subarray \(A[i..j]\).</p> <p>For example, suppose you have an array \(A[1,8]\) with values: [2, 4, 1, 7, 3, 0, 4, 2]. The query <code class="language-plaintext highlighter-rouge">range_sum(2, 6)</code> equals \(4+1+7+3+0 = 15\).</p> <p>These queries can be solved in constant time by maintaining the prefix sum array. This array \(P[1,n]\) stores, at any position \(i\), the sum of the values in \(A\) up to the \(i\)th position. In other words, \(P[i] = \sum_{k=1}^i A[k]\).</p> <p>The arrays \(A\) and \(P\) are shown in the figure below.</p> <div class="row mt-3 "> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/prefixsums/Prefixsums_1.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Armed with \(P\), a <code class="language-plaintext highlighter-rouge">range_sum(i,j)</code> query is resolved by calculating \(P[j]-P[i-1]\).</p> <p>Continuing the example shown in the figure above, <code class="language-plaintext highlighter-rouge">range_sum(2, 6)</code> is \(P[6] - P[1] = 17 - 2 = 15\).</p> <p><br/></p> <h4 id="prefix-sums-in-rust">Prefix Sums in Rust</h4> <p>In Rust, the combinator <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.scan"><code class="language-plaintext highlighter-rouge">scan</code></a> can produce the prefix sums (and much more) from an iterator.</p> <p><code class="language-plaintext highlighter-rouge">scan</code> is an iterator adapter that bears similarity to <a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.fold">fold</a>. Similar to <code class="language-plaintext highlighter-rouge">fold</code>, <code class="language-plaintext highlighter-rouge">scan</code> maintains an internal state, initially set to a seed value, which is modified by a closure taking both the current internal state and the current element from the iterator into account.</p> <p>The distinction between <code class="language-plaintext highlighter-rouge">scan</code> and <code class="language-plaintext highlighter-rouge">fold</code> is that the former produces a new iterator with all the states taken by its internal state, whereas the latter only returns the value of the final internal state.</p> <p>The following code snippet illustrates how to employ <code class="language-plaintext highlighter-rouge">scan</code> for computing prefix sums.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="n">a</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">];</span>

<span class="k">let</span> <span class="n">psums</span> <span class="o">=</span> <span class="n">a</span>
    <span class="nf">.iter</span><span class="p">()</span>
    <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
        <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
    <span class="p">})</span>
    <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

<span class="nd">assert!</span><span class="p">(</span><span class="n">psums</span><span class="nf">.eq</span><span class="p">(</span><span class="o">&amp;</span><span class="nd">vec!</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">14</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">17</span><span class="p">,</span> <span class="mi">21</span><span class="p">,</span> <span class="mi">23</span><span class="p">]));</span>
</code></pre></div></div> <p><br/></p> <h4 id="applications-of-prefix-sums">Applications of Prefix Sums</h4> <p>Range sum queries are exceptionally useful for solving a variety of other problems involving other kind of range queries. We present here solutions to three problems from CodeForces, which serve as examples of the power of prefix sums.</p> <p>Below, you’ll find links to these problems if you’d like to attempt them yourself before reading their solutions.</p> <ul> <li><a href="http://codeforces.com/problemset/problem/313/B?locale=en">Ilya and Queries</a></li> <li><a href="http://codeforces.com/problemset/problem/466/C?locale=en">Number of Ways</a></li> <li><a href="http://codeforces.com/problemset/problem/276/C?locale=en">Little Girl and Maximum</a></li> </ul> <p><br/></p> <h5 id="ilya-and-queries">Ilya and Queries</h5> <p><em>We have a string \(s=s_1s_2 \ldots s_n\) consisting only of characters \(a\) and \(b\) and we need to answer \(m\) queries.</em></p> <p><em>Each query \(q(l, r)\), where \(1 \leq l &lt; r \leq n\), asks for the number of positions \(i \in [l, r]\) such that \(s_i = s_{i+1}\).</em></p> <p>Let’s consider an example to better illustrate this problem.</p> <p>Given string \(s = aabbbaaba\). Consider the query \(q(3, 6)\). We are interested in the substring \(bbba\). So, the answer for this query is \(2\) because there are three positions followed by the same symbol, namely position \(1\), \(2\), and \(4\) in the substring.</p> <p>The idea is that of computing the binary vector \(B[1,n]\) such that \(B[i]=1\) if \(s_i == s_{i+1}\), \(0\) otherwise. This way, the answer to the query \(q(l,r)\) is \(\sum_{i=l} ^{r-1} B[i]\). Thus, each query can be solved in constant time by computing prefix-sums on vector \(B\).</p> <p>For example, the binary vector \(B\) for the string \(s = aabbbaaba\) is [1, 0, 1, 1, 0, 1, 0, 0, 0]. Its prefix sum array \(P\) is [1, 1, 2, 3, 3, 4, 4, 4, 4]. Therefore, the query \(q(3,6) = P[5]-P[2] = 3-1 = 2\).</p> <p>The Rust implementation is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(Debug)]</span>
<span class="k">struct</span> <span class="n">Ilya</span> <span class="p">{</span>
    <span class="n">psums</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Ilya</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">s</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">str</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">psums</span> <span class="o">=</span> <span class="n">s</span>
            <span class="nf">.as_bytes</span><span class="p">()</span>
            <span class="nf">.windows</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="nf">.map</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="k">if</span> <span class="n">w</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">w</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="p">{</span> <span class="mi">1usize</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0usize</span> <span class="p">})</span>
            <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
                <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
            <span class="p">})</span>
            <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

        <span class="k">Self</span> <span class="p">{</span> <span class="n">psums</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Queries use 0-based indexing</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">q</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">i</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">j</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">j</span> <span class="o">&lt;=</span> <span class="k">self</span><span class="py">.psums</span><span class="nf">.len</span><span class="p">());</span>

        <span class="k">self</span><span class="py">.psums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span> <span class="k">self</span><span class="py">.psums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="p">}</span> <span class="k">else</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="little-girl-and-maximum">Little Girl and Maximum</h5> <p><em>We are given an array \(A[1,n]\) and a set \(Q\) of \(q\) queries. Each query is a range sum query \(i,j\) which returns the sum of elements in \(A[i..j]\).</em></p> <p><em>The goal is to permute the elements in \(A\) in order to maximize the sum of the results of the queries in \(Q\).</em></p> <p>The main observation is that if we want to maximize the sum, we have to assign the largest values to the most frequently accessed entries. Thus, the solution consists of sorting both \(A\) by descending values and the indexes of \(A\) by descending frequency of access and pairing them in this order. Therefore, once we have computed the frequencies, the solution takes \(\Theta(n\log n)\) time.</p> <p>Thus, we are left with the problem of computing access frequencies. In other words, we want to compute the array \(F[1,n]\), where \(F[i]\) is the number of times the index \(i\) belongs to a query of \(Q\). Computing this vector by updating every single entry in \(F\) for each query takes \(O(nq)\) and, thus, is clearly infeasible.</p> <p>We require a faster algorithm to compute these frequencies. One possible solution involves using the <a href="blog/2023/sweepline/">sweep line algorithm</a>. Since the queries represent intervals, and calculating the frequencies equates to counting the number of overlapping intervals at each position, we can employ an approach similar to the one used in solving the <em>Maximum Number of Overlapping Intervals</em> problem, as detailed in these <a href="blog/2023/sweepline/">notes</a>.</p> <p>This solution has a time complexity of $\Theta(q\log q)$, due to the comparison-based sorting of interval endpoints. Since the endpoints in our problem have a maximum value of $n$, we can optimize the solution to run in $\Theta(q)$ using counting sort. However, there exists an alternative solution based on prefix sums, which is much simpler to implement.</p> <p>The main idea of this alternative solution is to construct an array \(U[1\ldots n]\) such that its prefix sums are equal to our target array \(F\). Interestingly, we need to modify just two entries of \(U\) to account for a query in \(Q\).</p> <p>Initially, all the entries of \(U\) are set to \(0\). For a query \(\langle l, r \rangle\), we add \(1\) to \(U[l]\) and subtract \(1\) from \(U[r+1]\). This way, the prefix sums are as follows:</p> <ul> <li>Unchanged for indexes less than \(l\).</li> <li>Increased by one for indexes in \([l, r]\).</li> <li>Unchanged for indexes greater than \(r\).</li> </ul> <p>Therefore, the prefix sum of \(U\) up to \(i\) equals \(F[i]\). This algorithm takes \(O(q+n)\) time.</p> <p>Here’s the Rust implemetation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// We assumes queries are 0-based indexed</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">little_girl</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i64</span><span class="p">],</span> <span class="n">q</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">a</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">u</span> <span class="o">=</span> <span class="nd">vec!</span><span class="p">[</span><span class="mi">0i64</span><span class="p">;</span> <span class="n">a</span><span class="nf">.len</span><span class="p">()];</span>

    <span class="k">for</span> <span class="o">&amp;</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span> <span class="k">in</span> <span class="n">q</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">l</span> <span class="o">&lt;=</span> <span class="n">r</span><span class="p">);</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="n">u</span><span class="nf">.len</span><span class="p">());</span>

        <span class="n">u</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">r</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="n">u</span><span class="nf">.len</span><span class="p">()</span> <span class="p">{</span>
            <span class="n">u</span><span class="p">[</span><span class="n">r</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">f</span> <span class="o">=</span> <span class="n">u</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="py">.collect</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">();</span>

    <span class="c1">// we sort both f and a in decreasing order, nothing changes</span>
    <span class="n">f</span><span class="nf">.sort_unstable</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">a_sorted</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.to_vec</span><span class="p">();</span>
    <span class="n">a_sorted</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">a_sorted</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.zip</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">freq</span><span class="p">)|</span> <span class="n">result</span> <span class="o">+</span> <span class="n">value</span> <span class="o">*</span> <span class="n">freq</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="number-of-ways">Number of Ways</h5> <p><em>Given an array \(A[1,n]\), count the number of ways to split the array into three contiguous parts so that they have the same sums.</em></p> <p>More formally, you need to find the number of such pairs of indices \(i\) and \(j\) (\(2 \leq i \leq j \leq n-1\)) such that:</p> \[\sum_{k=1}^{i-1} A[k] = \sum_{k=i}^{j} A[j] = \sum_{k=j+1}^n A[k]\] <p>For the solution, let \(S\) be the sum of the values in the array. If \(3\) does not divide \(S\), we conclude that the result is zero. Otherwise, we compute an array \(C\) that stores, at position \(i\), the number of suffixes of \(A[i\ldots n]\) that sum to \(\frac{S}{3}\). Then, we scan \(A\) from left to right to compute the prefix sums. Every time the prefix sum at position \(i\) is \(\frac{S}{3}\), we add \(C[i+2]\) to the result. This is because the part \(A[1..i]\) sums to \(S/3\) and can be combined with any pair of parts of \(A[i+1..n]\) where both parts sums to \(S/3\). Since the values in \(A[i+1..n]\) sum to \(2/3 S\), the number of such pairs is the number of suffixes that sum to \(S/3\) in \(A[i+2..n]\). Indeed, if one of this suffix sums to \(S/3\), say \(A[j..n]\), then we are sure that \(A[i+1, j-1]\) sums to \(S/3\).</p> <p>Here’s a Rust implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">number_of_ways</span><span class="p">(</span><span class="n">a</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="nb">i64</span><span class="p">])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">sum</span><span class="p">:</span> <span class="nb">i64</span> <span class="o">=</span> <span class="n">a</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.sum</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">sum</span> <span class="o">%</span> <span class="mi">3</span> <span class="o">!=</span> <span class="mi">0</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="n">target</span> <span class="o">=</span> <span class="n">sum</span> <span class="o">/</span> <span class="mi">3</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">c</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">a</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.rev</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">sum</span><span class="p">,</span> <span class="n">e</span><span class="p">|</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">sum</span> <span class="o">+=</span> <span class="n">e</span><span class="p">;</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">sum</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">counter</span><span class="p">,</span> <span class="n">sum</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1usize</span>
            <span class="p">};</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">counter</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">c</span><span class="nf">.reverse</span><span class="p">();</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">result</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">a</span><span class="p">[</span><span class="o">..</span><span class="n">a</span><span class="nf">.len</span><span class="p">()</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">v</span><span class="p">;</span>
        <span class="k">if</span> <span class="n">sum</span> <span class="o">==</span> <span class="n">target</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">+=</span> <span class="n">c</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="exercises">Exercises</h4> <ul> <li><a href="https://leetcode.com/problems/subarray-sum-equals-k/">Subarray Sum Equals K</a></li> <li><a href="https://leetcode.com/problems/continuous-subarray-sum/">Continuous Subarray Sum</a></li> <li><a href="https://codeforces.com/contest/1398/problem/C">Good Subarrays</a></li> <li><a href="https://codeforces.com/contest/1826/problem/D">Running Miles</a></li> </ul>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms,"/><category term="data-structures"/><summary type="html"><![CDATA[Prefix sums offer an elegant and efficient solution to a variety of problems. In this notes, we showcase several such problems and provide their solutions with Rust implementations.]]></summary></entry><entry><title type="html">Sweep Line Algorithm</title><link href="https://pages.di.unipi.it/rossano/blog/2023/sweepline/" rel="alternate" type="text/html" title="Sweep Line Algorithm"/><published>2023-10-09T07:01:00+00:00</published><updated>2023-10-09T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/sweepline</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/sweepline/"><![CDATA[<p>The <em>Sweep Line Algorithm</em> is an algorithmic paradigm used to solve a lot of problems in computational geometry efficiently. The sweep line algorithm can be used to solve problems on a line or on a plane.</p> <p><br/></p> <h4 id="maximum-number-of-overlapping-intervals">Maximum Number of Overlapping Intervals</h4> <p>Let’s start the description of this paradigm with a problem on a line.</p> <p><em>We are given a set of \(n\) intervals \([s_i, e_i]\) on a line.</em></p> <p><em>We say that two intervals \([s_i, e_i]\) and \([s_j, e_j]\) overlaps if and only if their intersection is not empty, i.e., if there exist at least a point \(x\) belonging to both intervals.</em></p> <p><em>The goal is to compute the maximum number of overlapping intervals.</em></p> <p>For example, consider the set of intevals in the figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this example, we have a set of \(10\) intervals. The maximum number of overlapping intervals is \(5\) (at positions \(3\) and \(4\)).</p> <p>The sweep line algorithm employs an imaginary <em>vertical line</em> sweeping over the x-axis. As it progresses, we maintain a running solution to the problem at hand. The solution is updated when the vertical line reaches certain key points where some <em>event</em> happen. The type of the event tells us how to update the current solution.</p> <p>To apply this paradigm to our problem, we let the sweep line move from left to right and stop at the beginning or the end of the intervals. These are the important points at which an event occurs: new intervals start or end. We also maintain a counter which keeps track of the number of intervals that are currently intersecting the sweep line, along with the maximum value reached by the counter so far. For each point, we first add to the counter the number of intervals that begin at that point, and then we subtract the number of intervals that end at that point.</p> <p>The figure below shows the points touched by the sweep line and the values of the counter.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps_sweep.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Note that the sweep line touches only points on the x-axis where an event occurs. For example, points \(1\) and \(6\) are not taken into consideration. This is important because the number of considered points, and thus the time complexity, is proportional to the number of intervals and not to the size of the x-axis.</p> <p>Here is a Rust implementation. We represent each interesting point as a pair consisting of the point and the kind, which is either <code class="language-plaintext highlighter-rouge">begin</code> or <code class="language-plaintext highlighter-rouge">end</code>. Then, we sort the vector of pairs in increasing order. Finally, we compute every state of the counter and its largest value. The correctness of the solution is based on a specific detail in the sorting step: since <code class="language-plaintext highlighter-rouge">begin</code> is considered smaller than <code class="language-plaintext highlighter-rouge">end</code>, if two points are the same, we first have pairs with <code class="language-plaintext highlighter-rouge">begin</code> and then pairs with <code class="language-plaintext highlighter-rouge">end</code>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">Event</span> <span class="p">{</span>
    <span class="n">Begin</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_overlapping</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.flat_map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)|</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">Begin</span><span class="p">),</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">End</span><span class="p">)])</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">pairs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">pairs</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">kind</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="nn">Event</span><span class="p">::</span><span class="n">Begin</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">counter</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="closest-pair-of-points">Closest Pair of Points</h4> <p>Let’s tackle a second problem to apply the sweep line paradigm to a two-dimensional problem.</p> <p><em>We are given a set of \(n\) points in the plane.</em></p> <p><em>The goal is to find the closest pair of points in the set. The distance between two points \((x_1, y_1)\) and \((x_2,y_2)\) is the Euclidian distance \(d((x_1,y_1), (x_2,y_2)) = \sqrt{(x_1-x_2)^2 +(y_1-y_2)^2}\).</em></p> <p>A brute force algorithm calculates the distances between all possible pairs of points, resulting in a time complexity of \(\Theta(n^2)\).</p> <p>A faster algorithm employs the sweep line paradigm. We start by sorting the points in increasing order of their x-coordinates. We keep track of the shortest distance, denoted as \(\delta\), seen so far. Initially, \(\delta\) is set to the distance between an arbitrary pair of points.</p> <p>We use a vertical sweep line to iterate through the points, attempting to improve the current shortest distance \(\delta\). Consider the point \(p = (x, y)\) just reached by the vertical sweep line. We can improve \(\delta\) if the closest point <em>to the left</em> of \(p\) has a distance smaller than \(\delta\). If such a point exists, it must have an x-coordinate in the interval \([x - \delta, x]\), as it is to the left of \(p\), and a y-coordinate in the interval \([y - \delta, y + \delta]\).</p> <p>The figure below shows the rectangle within which this point must lie. We have a fact that, at a first glance, may seem quite surprising: <em>there can be at most \(6\) points within the rectangle</em>. The \(6\) circles within the perimeter of the rectangle represent points that are at distance exactly \(\delta\) apart from each other. See the <em>Section 5.4 of Algorithm Design by Kleinberg and Tardos</em> for a proof of this fact.</p> <p>For our purposes, a slightly weaker result is sufficient, which states that <em>the rectangle contains at most \(8\) points</em>.</p> <p>To understand why, consider the \(8\) squares in the figure above. Each of these squares, including its perimeter, can contain at most one point. Assume, for the sake of contradiction, that a square contains two points, denoted as \(q\) and \(q'\). The distance between \(q\) and \(q'\) is smaller than \(\delta\). If point \(q'\) exists, it would have already been processed by the sweep line because it has an x-coordinate smaller than that of \(p\). However, this is not possible, because otherwise the value of \(\delta\) would be smaller than its current value.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/ClosestPair.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Now that we have the intuition of the solution, let’s add more details. The algorithm maintains a BST with points sorted by their y-coordinates. When we process point \(p=(x,y)\), we iterate over the points with y-coordinates in the interval \([y-\delta, y+\delta]\). If the current point has a \(x\)-coordinate smaller than \(x-\delta\), we remove this point from the set. It will be never useful anymore. Otherwise, we compute its distance with \(p\) and update \(\delta\) if needed. Before moving the sweep line to the next point, we insert \(p\) in the set.</p> <p>What is the complexity of this algorithm? Identifying the range of points with the required y-coordinates takes \(\Theta(\log n)\) time. Iterating over the points in this range takes constant time per point and removing one of them takes \(\Theta(\log n)\) time.</p> <p>How many points do we need to iterate over? There can be at most \(6\) points that have an x-coordinate greater than or equal to \(x-\delta\) and therefore survive. On the other hand, there can be many points with smaller x-coordinates. However, since each point is inserted and subsequently removed from the set at most once during the execution of the algorithm, the cost of dealing with all these points is at most \(\Theta(n \log n)\).</p> <p>The following is a Rust implementation of this algorithm. There are two differences from the above description. First, we compute the squared Euclidean distance. This way, we avoid the computation of the square root, which is slow and results in a floating-point value The second difference is that <strong>we swap the roles of x and y</strong>. Therefore, we process the points by ascending y-coordinate and use a horizontal sweep line. This is easier to implement in Rust. Indeed, with the original approach, we would need to insert points into a <a href="https://doc.rust-lang.org/std/collections/struct.BTreeMap.html"><code class="language-plaintext highlighter-rouge">BTreeSet</code></a> ordered by y-coordinate, which is the second component of the pair. This ordering is not possible with a <code class="language-plaintext highlighter-rouge">BTreeSet</code> unless we create a wrapper for a point that implements the required behavior for a comparison. Instead, if we swap the roles of x and y, the ordering by y is only required during the sorting step, which can be customized using the <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.sort_unstable_by_key"><code class="language-plaintext highlighter-rouge">sort_unstable_by_key</code></a> method.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">pub</span> <span class="k">fn</span> <span class="nf">distance_squared</span><span class="p">(</span><span class="n">p</span><span class="p">:</span> <span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">),</span> <span class="n">q</span><span class="p">:</span> <span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">))</span> <span class="k">-&gt;</span> <span class="nb">i64</span> <span class="p">{</span>
    <span class="p">(</span><span class="n">p</span><span class="na">.0</span> <span class="o">-</span> <span class="n">q</span><span class="na">.0</span><span class="p">)</span><span class="nf">.pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">p</span><span class="na">.1</span> <span class="o">-</span> <span class="n">q</span><span class="na">.1</span><span class="p">)</span><span class="nf">.pow</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeSet</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">ops</span><span class="p">::</span><span class="nn">Bound</span><span class="p">::</span><span class="n">Included</span><span class="p">;</span>

<span class="c1">// Returns the (squared) Euclidean distance between the closest pair of </span>
<span class="c1">// points in `points`</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">closest_pair</span><span class="p">(</span><span class="n">points</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="p">[(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">i64</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">if</span> <span class="n">points</span><span class="nf">.len</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">points</span><span class="nf">.sort_unstable_by_key</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="p">(</span><span class="n">p</span><span class="na">.1</span><span class="p">,</span> <span class="n">p</span><span class="na">.0</span><span class="p">));</span> <span class="c1">// sort by y</span>

    <span class="k">let</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.1</span><span class="p">;</span>
    <span class="k">let</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">points</span><span class="nf">.last</span><span class="p">()</span><span class="o">?</span><span class="na">.1</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">delta</span> <span class="o">=</span> <span class="nf">distance_squared</span><span class="p">(</span><span class="n">points</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span><span class="p">:</span> <span class="n">BTreeSet</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i64</span><span class="p">,</span> <span class="nb">i64</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">for</span> <span class="o">&amp;</span><span class="n">point</span> <span class="k">in</span> <span class="n">points</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// Search by x and select the points with too small y-coordinate that we remove</span>
        <span class="c1">// to not touch them again in the future</span>
        <span class="k">let</span> <span class="n">to_delete</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">set</span>
            <span class="nf">.range</span><span class="p">((</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)),</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)),</span>
            <span class="p">))</span>
            <span class="nf">.filter</span><span class="p">(|</span><span class="n">p</span><span class="p">|</span> <span class="n">p</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span> <span class="o">&gt;=</span> <span class="n">point</span><span class="na">.0</span><span class="p">)</span>
            <span class="nf">.cloned</span><span class="p">()</span>
            <span class="nf">.collect</span><span class="p">();</span>

        <span class="c1">// Remove those points</span>
        <span class="k">for</span> <span class="n">p</span> <span class="k">in</span> <span class="n">to_delete</span> <span class="p">{</span>
            <span class="n">set</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="n">p</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">// Search again and compute the distances with survived points.</span>
        <span class="c1">// Update delta if needed.</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">set</span>
            <span class="nf">.range</span><span class="p">((</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">-</span> <span class="n">delta</span><span class="p">,</span> <span class="n">min_y</span><span class="p">)),</span>
                <span class="nf">Included</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">point</span><span class="na">.0</span> <span class="o">+</span> <span class="n">delta</span><span class="p">,</span> <span class="n">max_y</span><span class="p">)),</span>
            <span class="p">))</span>
            <span class="nf">.fold</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">p</span><span class="p">|</span> <span class="n">acc</span><span class="nf">.min</span><span class="p">(</span><span class="nf">distance_squared</span><span class="p">(</span><span class="n">point</span><span class="p">,</span> <span class="n">p</span><span class="p">)));</span>

        <span class="n">set</span><span class="nf">.insert</span><span class="p">(</span><span class="n">point</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="nf">Some</span><span class="p">(</span><span class="n">delta</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="further-readings-and-exercises">Further Readings and Exercises</h4> <ul> <li><a href="https://usaco.guide/plat/sweep-line?lang=cpp">USACO Guide</a></li> <li><a href="https://www.topcoder.com/thrive/articles/Line%20Sweep%20Algorithms">Top Coder</a></li> <li><a href="https://en.wikipedia.org/wiki/Fortune%27s_algorithm">Fortune’s algorithm</a></li> <li><a href="https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/">Check if all the integers in a range are covered</a></li> <li><a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=943">Cow Steeplechase II</a></li> </ul>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms,"/><category term="data-structures"/><summary type="html"><![CDATA[The Sweep Line Algorithm is a powerful paradigm for solving a variety of problems in computational geometry. In these notes, we employ it to address problems both on a line and in a plane, providing Rust implementations for their solutions.]]></summary></entry><entry><title type="html">Tree Traversals in Rust</title><link href="https://pages.di.unipi.it/rossano/blog/2023/handson12324/" rel="alternate" type="text/html" title="Tree Traversals in Rust"/><published>2023-10-03T07:01:00+00:00</published><updated>2023-10-03T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/handson12324</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/handson12324/"><![CDATA[<p>This is the text of first hands-on of the the course <a href="competitive/"><em>Competitive Programming and Contests</em></a> at University of Pisa in the accademic year 2023-24.</p> <p>The objective of this hands-on is to implement recursive traversals of a binary tree in Rust. These exercises are valuable for preparing for coding interviews and are worth attempting even if you are not enrolled in the course.</p> <p><br/></p> <h4 id="basic-binary-tree-implementation">Basic Binary Tree Implementation</h4> <p>Let’s begin by describing a basic binary tree implementation in Rust.</p> <p>In our implementation, a node is represented as a struct with three fields: the <code class="language-plaintext highlighter-rouge">key</code> of the node, and the ids of its <code class="language-plaintext highlighter-rouge">id_left</code> and <code class="language-plaintext highlighter-rouge">id_right</code> children. We represent the entire tree using a vector of <code class="language-plaintext highlighter-rouge">Node</code>s. Each node is implicitly assigned an ID that corresponds to its position in the vector.</p> <p>Therefore, a node is defined as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">id_left</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">id_right</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">id_left</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">id_right</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We have chosen to use <code class="language-plaintext highlighter-rouge">u32</code> as the data type for the <code class="language-plaintext highlighter-rouge">key</code>. Implementing a generic version of the <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code> structure is left as an exercise, albeit potentially quite boring one. Both <code class="language-plaintext highlighter-rouge">id_left</code> and <code class="language-plaintext highlighter-rouge">id_right</code> are of type <code class="language-plaintext highlighter-rouge">Option&lt;usize&gt;</code> and store the IDs of the left and right children of the node, respectively. If a child does not exist, the corresponding ID is set to <code class="language-plaintext highlighter-rouge">None</code>.</p> <p>To create a node, you can use the <code class="language-plaintext highlighter-rouge">new</code> function and specify its <code class="language-plaintext highlighter-rouge">key</code>. The newly created node is considered a leaf and, thus, both children are <code class="language-plaintext highlighter-rouge">None</code>.</p> <p>Now, we are prepared to define the struct <code class="language-plaintext highlighter-rouge">Tree</code>, which is just a vector of nodes.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>In our implementation, we have chosen not to allow empty trees. This simplifies the code a little bit. However, it’s easy to reverse this decision if necessary.</p> <p>You can create a new tree using the <code class="language-plaintext highlighter-rouge">with_root(key: u32)</code> function, which initializes a new tree with a root having the specified <code class="language-plaintext highlighter-rouge">key</code>. The ID of the root node is always <code class="language-plaintext highlighter-rouge">0</code>.</p> <p>We have also decided to restrict operations to only insertions of new nodes; that is, deletions or modifications of existing nodes are not allowed. This limitation aligns with our objectives, as our primary focus is on tree traversal.</p> <p>To insert a new node, you can use the <code class="language-plaintext highlighter-rouge">add_node</code> method. When adding a new node, you need to specify its <code class="language-plaintext highlighter-rouge">parent_id</code>, its <code class="language-plaintext highlighter-rouge">key</code>, and a boolean value, <code class="language-plaintext highlighter-rouge">is_left</code>, which indicates whether the node should be the left or right child of its parent. The method panics if the <code class="language-plaintext highlighter-rouge">parent_id</code> is invalid or if the parent node has already assigned the child we are trying to insert.</p> <p>The implementation of a tree is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_root</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">)],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Adds a child to the node with `parent_id` and returns the id of the new node. </span>
    <span class="cd">/// The new node has the specified `key`. The new node is the left  child of the  </span>
    <span class="cd">/// node `parent_id` iff `is_left` is `true`, the right child otherwise.</span>
    <span class="cd">///</span>
    <span class="cd">/// # Panics</span>
    <span class="cd">/// Panics if the `parent_id` does not exist, or if the node `parent_id ` has  </span>
    <span class="cd">/// the child already set.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">is_left</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span>
            <span class="n">parent_id</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="s">"Parent node id does not exist"</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="n">is_left</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_left</span> <span class="o">==</span> <span class="nb">None</span><span class="p">,</span>
                <span class="s">"Parent node has the left child already set"</span>
            <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_right</span> <span class="o">==</span> <span class="nb">None</span><span class="p">,</span>
                <span class="s">"Parent node has the right child already set"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">child_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="k">if</span> <span class="n">is_left</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_left</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_right</span>
        <span class="p">};</span>

        <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_id</span><span class="p">);</span>

        <span class="n">child_id</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="computing-the-sum-of-keys-in-a-binary-tree">Computing the Sum of Keys in a Binary Tree</h4> <p>Let’s implement a simple tree traversal to compute the sum of the keys in a binary tree. This can serve as an example for implementing the solutions for the three exercises below.</p> <p>We will use a recursive function called <code class="language-plaintext highlighter-rouge">rec_sum(&amp;self, node_id: Option&lt;usize&gt;</code>). This function takes a <code class="language-plaintext highlighter-rouge">node_id</code> as input and computes the sum of all the keys in the subtree rooted at <code class="language-plaintext highlighter-rouge">node_id</code>. There are two possibilities. If <code class="language-plaintext highlighter-rouge">node_id</code> is <code class="language-plaintext highlighter-rouge">None</code>, the subtree is empty, and thus, the sum is <code class="language-plaintext highlighter-rouge">0</code>. However, if <code class="language-plaintext highlighter-rouge">node_id</code> refers to a valid node, the sum of the keys is equal to the key of the current node plus the sums of its left and right subtrees. These latter sums are computed recursively.</p> <p>Here is the Rust code. Note that we have the <code class="language-plaintext highlighter-rouge">sum</code> method, which is responsible for calling <code class="language-plaintext highlighter-rouge">rec_sum</code> at the root.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Returns the sum of all the keys in the tree</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// A private recursive function that computes the sum of</span>
<span class="cd">/// nodes in the subtree rooted at `node_id`.</span>
<span class="k">fn</span> <span class="nf">rec_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="n">node_id</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"Node id is out of range"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sum_left</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="n">node</span><span class="py">.id_left</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sum_right</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="n">node</span><span class="py">.id_right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">sum_left</span> <span class="o">+</span> <span class="n">sum_right</span> <span class="o">+</span> <span class="n">node</span><span class="py">.key</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div> <p>The code described so far is <a href="/rossano/assets/zip/handson1_2324.zip">here</a>.</p> <p><br/></p> <h4 id="exercise-1">Exercise #1</h4> <p>Write a method to check if the binary tree is a <strong>Binary Search Tree</strong>.</p> <p><br/></p> <h4 id="exercise-2">Exercise #2</h4> <p>Write a method to check if the binary tree is <strong>balanced</strong>.</p> <p>A tree is considered balanced if, for each of its nodes, the heights of its left and right subtrees differ by at most one.</p> <p><br/></p> <h4 id="exercise-3">Exercise #3</h4> <p>Write a method to check if the binary tree is a <strong>max-heap</strong>.</p> <p>A max-heap is a <em>complete</em> binary tree in which every node satisfies the <em>max-heap property</em>. A node satisfies the max-heap property if its key is greater than or equal to the keys of its children.</p> <p><br/></p> <h4 id="test-your-solutions">Test Your Solutions</h4> <p>In the code snippet below, we provide a (limited) set of tests for the <code class="language-plaintext highlighter-rouge">sum</code> method. This code also shows how to construct a binary tree using our implementation. To ensure the robustness of your solutions, we strongly recommend adding a comprehensive suite of tests</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_sum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">Tree</span><span class="p">::</span><span class="nf">with_root</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>

        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// id 1</span>
        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="c1">// id 2</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">37</span><span class="p">);</span>

        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="c1">// id 3</span>
        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// id 4</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">64</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="submission">Submission</h4> <p>Submit a file <code class="language-plaintext highlighter-rouge">lib.rs</code> and a file <code class="language-plaintext highlighter-rouge">Handson1_solution_YOUR_NAME.pdf</code> to <a href="mailto:rossano.venturini@gmail.com">rossano.venturini@gmail.com</a> by 19/10/2023.</p> <ul> <li>Source code <code class="language-plaintext highlighter-rouge">lib.rs</code> contains your implementations and a large set of tests.</li> <li>A report <code class="language-plaintext highlighter-rouge">Handson1_solution_YOUR_NAME.pdf</code> that briefly describes your implementations.</li> </ul> <p>Before submitting your solutions,</p> <ul> <li>make sure your implementation successfully passes all the tests.</li> <li>use <code class="language-plaintext highlighter-rouge">cargo fmt</code> to format your code.</li> <li>use <code class="language-plaintext highlighter-rouge">cargo clippy</code> to check your code.</li> <li>use <a href="https://grammarly.com/">Grammarly</a> to improve your English and avoid <a href="https://en.wiktionary.org/wiki/tpyo#English">tpyos</a> :-). There is an <a href="https://marketplace.visualstudio.com/items?itemName=znck.grammarly">extension for vscode</a>.</li> </ul> <p><br/></p> <h4 id="cheating">Cheating</h4> <p><strong>Very important!</strong> You are allowed to verbally discuss solutions with other students, <strong>BUT</strong> you must implement all solutions by yourself. Therefore, sharing implementations with others is strictly <strong>forbidden</strong>.</p>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms,"/><category term="data-structures"/><summary type="html"><![CDATA[First hands-on of a.y. 23/24 for the course Competitive Programming and Contests at University of Pisa]]></summary></entry><entry><title type="html">Applications of Binary Search</title><link href="https://pages.di.unipi.it/rossano/blog/2023/binarysearch/" rel="alternate" type="text/html" title="Applications of Binary Search"/><published>2023-09-23T07:01:00+00:00</published><updated>2023-09-23T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/binarysearch</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/binarysearch/"><![CDATA[<p>Binary search is undoubtedly one of computer science’s most well-known and fundamental algorithms. This elegant and efficient algorithm searches for a specific key, say \(k\), within a sorted array of \(n\) items, say \(A[0, n-1]\). Binary search repeatedly divides the search range in half until the target element is found or the search range becomes empty, resulting in a time complexity of \(\Theta(\log n)\). This is one of the easiest applications of the <em>Divide-and-Conquer paradigm</em>.</p> <p><br/></p> <h4 id="divide-and-conquer-paradigm">Divide-and-Conquer Paradigm</h4> <p>The divide-and-conquer paradigm tackles a complex problem by breaking it down into smaller, more manageable subproblems of the same type. These subproblems are addressed recursively, and their solutions are combined to yield the solution for the original problem.</p> <p>More precisely, a divide-and-conquer-based algorithm follows three main steps:</p> <ul> <li><strong>Divide</strong>: The initial problem instance is partitioned into smaller subinstances of the same problem.</li> <li><strong>Solve</strong>: These subinstances are then solved recursively. If a subinstance reaches a certain manageable size, a straightforward approach is employed to solve it directly.</li> <li><strong>Combine</strong>: The solutions obtained from the subinstances are combined to obtain the final solution for the original, larger instance of the problem.</li> </ul> <p><br/></p> <h4 id="binary-search-implementation">Binary Search Implementation</h4> <p>We can apply the above paradigm to search for a key in a sorted array of \(n\) elements within \(\Theta(\log n)\) comparisons.</p> <ul> <li><strong>Divide</strong>: The array is divided into two roughly equal halves, centering around the middle element of the array.</li> <li><strong>Solve</strong>: Compare the middle element of the array with the searched key. If the middle element is a match, the search stops successfully. If not, we recursively search for the key only in one of the two halves that may contain based on whether the desired key is greater or lesser than the middle element.</li> <li><strong>Combine</strong>: There is nothing to combine. The algorithm simply reports the final answer.</li> </ul> <p>A Rust implementation of binary search is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span>   <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">),</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>    <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">None</span>
<span class="p">}</span>
</code></pre></div></div> <p>The generic implementation above works for types that are <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code class="language-plaintext highlighter-rouge">Ord</code></a>. <code class="language-plaintext highlighter-rouge">Ord</code> is the trait for types that form a total order. The method <code class="language-plaintext highlighter-rouge">cmp</code> returns an <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code class="language-plaintext highlighter-rouge">Ordering</code></a> between two elements: In our case, the <code class="language-plaintext highlighter-rouge">key</code> we are looking for and the element in the middle. We use the result of this comparison to check for a match or to move either <code class="language-plaintext highlighter-rouge">low</code> after <code class="language-plaintext highlighter-rouge">middle</code> or <code class="language-plaintext highlighter-rouge">high</code> to <code class="language-plaintext highlighter-rouge">middle</code>. Note that the position <code class="language-plaintext highlighter-rouge">high</code> is not included in the range.</p> <p>It is worth noticing the expression <code class="language-plaintext highlighter-rouge">middle = low + (high - low)/2</code> to compute the position in the middle of the current range. A lot of existing implementations on the net use instead the expression <code class="language-plaintext highlighter-rouge">middle = (low + high) / 2</code>, which is buggy. Indeed, it leads to overflow if <code class="language-plaintext highlighter-rouge">low + high</code> is greater than <code class="language-plaintext highlighter-rouge">usize::MAX</code>.</p> <p>It is also important to observe that when there are multiple occurrences of the searched key, the function returns the position of the first encountered occurrence, not necessarily the first occurrence in the vector. This behavior aligns with the implementation of <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search">binary search</a> in Rust. However, it is often very useful to report the position of the first occurrence of the searched key. We can obtain this behavior with the following implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span> <span class="c1">// note that high is excluded</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">);</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span>
            <span class="p">}</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this implementation, when a match is found, we do not immediately return its position. Instead, we update the <code class="language-plaintext highlighter-rouge">ans</code> variable and set <code class="language-plaintext highlighter-rouge">high</code> to the position of this occurrence. This way, we continue the search in the first half of the array, seeking additional occurrences of the <code class="language-plaintext highlighter-rouge">key</code>. If there are more matches, <code class="language-plaintext highlighter-rouge">ans</code> will be further updated with smaller positions.</p> <p>As a useful exercise you could try to modify the code above to return the smallest position such that the element at that position is greater than or equal to <code class="language-plaintext highlighter-rouge">key</code>. In other word, if the <code class="language-plaintext highlighter-rouge">key</code> is not in the slice, it returns the position of its successor.</p> <p>Instead of implementing the code above, we can find the first (or even the last) occurrence of a key with <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.partition_point">partition_point</a> method of the standard library. This method is even more generic that our code above. Indeed, it returns the index of the partition point in a sorted vector according to any given predicate.</p> <p><br/></p> <h4 id="binary-search-the-answer">Binary Search the Answer</h4> <p>Consider a problem where all the possible candidate answers are restricted to a range of values between certain <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> possible answers. In other words, any candidate answer \(x\) falls within the range <code class="language-plaintext highlighter-rouge">[low, high)</code>. We also have a boolean predicate <code class="language-plaintext highlighter-rouge">pred</code> defined on the candidate answers that tells us if an answer is good or not for our aims. Our goal is to find the largest good answer.</p> <p>When no assumptions are made about the predicate, we cannot do better than evaluating the predicate on all the possible answers. So, the number of times we evaluate the predicate is \(\Theta(n)\), where \(n = high-low\) is the number of possible answers.</p> <p>Instead, if the predicate is <strong>monotone</strong>, we can <em>binary search the answer</em> to find it with \(\Theta(\log n)\) evaluations. This strategy is implemented by the generic function below.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">FromPrimitive</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">Num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialOrd</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">binary_search_range</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">low</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Num</span> <span class="o">+</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="n">FromPrimitive</span> <span class="o">+</span> <span class="nb">Copy</span><span class="p">,</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="nn">FromPrimitive</span><span class="p">::</span><span class="nf">from_u64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">match</span> <span class="nf">pred</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="nn">T</span><span class="p">::</span><span class="nf">one</span><span class="p">();</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>The function takes the extremes (of type <code class="language-plaintext highlighter-rouge">T</code>) of the range and the predicate as an argument. We use the external crate <a href="https://docs.rs/num/latest/num/">Num</a> to require some basic arithmetic operations for type <code class="language-plaintext highlighter-rouge">T</code>. The function returns the largest element of the range satisfying the predicate, or <code class="language-plaintext highlighter-rouge">None</code> if there is no such element.</p> <p>Let’s use this function to solve problems.</p> <p><br/></p> <h5 id="sqrt">Sqrt</h5> <p>An example is the problem <em><a href="https://leetcode.com/problems/sqrtx/">Sqrt</a></em>.</p> <p><em>We are given a non-negative integer \(v\) and we want to compute the square root of \(v\) rounded down to the nearest integer.</em></p> <p>The possible answers are in \([0, v]\). For each candidate answer \(x\), the predicate is \(p(x) = x^2 &lt;= v\). Thus, we can find the result in \(\Theta(\log v)\) time.</p> <p>Thus, a one-line solution is</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="social-distancing">Social Distancing</h5> <p>Let’s consider <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1038">another problem</a>.</p> <p><em>We have a sequence of \(n\) mutually-disjoint intervals. The extremes of each interval are non-negative integers. We aim to find \(c\) integer points within the intervals such that the smallest distance \(d\) between consecutive selected points is <strong>maximized</strong>.</em></p> <p>Guess what? A solution to this problem binary searches the answer, the target distance \(d\). Why is this possible? If a certain distance is feasible (i.e., there exists a selection of points at that distance), then any smaller distance is also feasible. Thus, the feasibility is a monotone boolean predicate that we can use to binary search the answer.</p> <p>As the candidate answers range from \(1\) to \(l\), where \(l\) is the overall length of the intervals, the solution takes \(\Theta(\log l)\) evaluations of the predicate.</p> <p>What’s the cost of evaluating the predicate? Well, we first sort the intervals. Now, we can evaluate any candidate distance \(d'\) by scanning the sorted intervals from left to right. First, we select the left extreme of the first interval as the first point. Then, we move over the intervals, and we choose greedly the first point, which is at a distance at least \(d'\) from the previous one. Thus, an evaluation of the predicate takes \(\Theta(n)\) time.</p> <p>The overall running time is \(\Theta(n\log l)\).</p> <p>A Rust implementation of this strategy is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">select_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">interval</span><span class="p">|</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">interval</span><span class="na">.1</span> <span class="o">-</span> <span class="n">interval</span><span class="na">.0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// overall length</span>

    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="p">{</span>
        <span class="c1">// there is no solution</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intervals</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="c1">// A closure implements our predicate</span>
    <span class="k">let</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">|</span><span class="n">d</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">last_selected</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">interval</span> <span class="k">in</span> <span class="n">intervals</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="na">.1</span> <span class="p">{</span>
                <span class="n">last_selected</span> <span class="o">=</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">);</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span>
    <span class="p">};</span>

    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="other-problems">Other Problems</h5> <ul> <li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></li> <li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find the minimum in a rotated sorted array</a></li> <li><a href="https://leetcode.com/problems/find-peak-element/">Search for a peak in an (unsorted) array</a></li> </ul>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[Binary search is undeniably one of the most renowned and fundamental algorithms in computer science. In these notes, we delve into problems that can be solved using the idea of 'Binary Searching for the Answer'.]]></summary></entry><entry><title type="html">Sliding Window Maximum</title><link href="https://pages.di.unipi.it/rossano/blog/2023/swm/" rel="alternate" type="text/html" title="Sliding Window Maximum"/><published>2023-09-10T07:01:00+00:00</published><updated>2023-09-10T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/swm</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/swm/"><![CDATA[<p>The <em>Sliding Window Maximum</em> problem is a classic algorithmic challenge that involves processing an array in a sliding window fashion. The goal is to find the maximum element within a fixed-size window as it moves through the array.</p> <p>Formally, the problem can be defined as follows.</p> <p><em>Given an array \(A[0,n-1]\) and an integer \(k\), the goal is to find the maximum of each subarray (window) of \(A\) of size \(k\).</em></p> <p>The simplest approach to address this problem involves handling each of the \(n-k+1\) windows independently. Within each window, we calculate its maximum by scanning through all its elements, which takes \(\Theta(k)\) time. Consequently, this straightforward brute force solution operates in \(\Theta(nk)\) time.</p> <p>Here is a Rust implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.len</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">current_slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">max_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_slice</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>A more elegant one-line implementation uses <a href="https://learning-rust.github.io/docs/combinators/">combinators</a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">v</span><span class="nf">.windows</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div> <p>The inefficiency of this solution stems from the fact that when calculating the maximum of a window, we disregard all the computations previously performed to determine the maxima of the preceding windows.</p> <p><br/></p> <h4 id="bst-based-solution">BST-based Solution</h4> <p>Enhancing the brute force solution above entails leveraging a data structure to efficiently handle the next window while capitalizing on the progress made in processing the preceding window. The design of a faster solution begins with two straightforward observations:</p> <p>Firstly, we can represent the elements within a window as a multiset \({\cal M}\) of size \(k\). In this representation, the result for the window is essentially the largest element contained within this multiset.</p> <p>Secondly, when we transition from one window to the next, only two elements change: the first element of the first window exits from the scene, and the last element of the second one enters. Consequently, we can derive the multiset of the new window from the multiset of the previous window by simply adding one element and removing another one.</p> <p>Hence, we require a data structure capable of performing three crucial operations on a (multi)set: inserting a new element, deleting an arbitrary element, and efficiently retrieving the maximum element within the multiset. By employing such a versatile data structure, we can seamlessly move the window across the array while efficiently updating and querying the multiset to calculate the desired results. Now the question is: What’s the best data structure supporting these operations? A <em>Balanced Binary Search Tree</em> (BBST) supports any of these operations in \(\Theta(\log |{\cal M}|)\), where \(|{\cal M}|\) is the number of elements in the multiset (and it is optimal in the comparison model). This way, we can solve the problem in \(\Theta(n \log k)\) time.</p> <p>A Rust implementation of this strategy is as follows. Here we use <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html">BTreeSet</a>. A <code class="language-plaintext highlighter-rouge">BTreeSet</code> is BST-like data structure that represents a set of unique, ordered elements. It provides efficient implmementation of insertion (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.insert">insert()</a>), deletion (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.remove">remove()</a>), and maximum (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.last">last()</a>) operations. The only issue to deal with is that a <code class="language-plaintext highlighter-rouge">BTreeSet</code> does not store repeated values. For this reason, we store elements together with their positions. This way, every element in the array is inseerted as a unique pair in the <code class="language-plaintext highlighter-rouge">BTreeSet</code>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeSet</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">bst</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">max_sf</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">set</span><span class="nf">.insert</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>

        <span class="n">max_sf</span> <span class="o">=</span> <span class="n">max_sf</span><span class="nf">.max</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// keep track of the max so far to avoid a costly query to the set</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="p">{</span>
            <span class="n">set</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">));</span>
            <span class="k">if</span> <span class="n">max_sf</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">max_sf</span> <span class="o">=</span> <span class="n">set</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_sf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this implementation we’ve incorporated a straightforward optimization to reduce the number of calls to <code class="language-plaintext highlighter-rouge">set.last()</code>. We keep track of the maximum element encountered so far, denoted as <code class="language-plaintext highlighter-rouge">max_sf</code>. We only call <code class="language-plaintext highlighter-rouge">set.last()</code> when <code class="language-plaintext highlighter-rouge">max_sƒ</code> might be invalidated by a delition of an element equals to <code class="language-plaintext highlighter-rouge">max_sƒ</code>.</p> <p><br/></p> <h4 id="heap-based-solution">Heap-based Solution</h4> <p>It’s worth noting an alternative solution that, theoretically, is slightly less efficient than the previous one (i.e., \(\Theta(n\log n)\) instead of \(\Theta(n\log k)\)). However, in practice, this alternative solution often proves to be faster.</p> <p>As we are talking about maximum, the immediate choice that springs to mind is the priority queue, with its most renowned manifestation being the <em>(max-)heap</em>. A max-heap stores a set \(n\) of keys and supports three operations:</p> <ul> <li>Insert an element in the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.push">push</a>).</li> <li>Report the maximum element in the max-heap. The operation takes \(O(1)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.peek">peek</a>).</li> <li>Extract the maximum element from the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.pop">pop</a>).</li> </ul> <p>We can solve the sliding window maximum problem by employing a max-heap and scanning the array from left to right. Here’s how it works.</p> <p>Initially, we populate a max-heap with the first \(k\) elements of \(A\) along with their respective positions. This gives us the maximum within the initial window, which is essentially the maximum provided by the heap.</p> <p>As we move on to process the remaining elements of \(A\) one by one, we insert each current element into the heap alongside its position. We then request the heap to provide us with the current maximum. However, it’s important to note that this reported maximum element might fall outside the current window’s boundaries. To address this, we continuously extract elements from the heap until the reported maximum is within the constraints of the current window.</p> <p>A Rust implementation of this strategy is the following one.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">heap</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">heap</span><span class="nf">.pop</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>It’s worth noting that with this approach, there are a total of \(n\) insertions and at most \(n\) extractions of the maximum in the heap. Since the maximum number of elements present in the heap at any given time is up to \(n\), each of these operations takes \(\Theta(\log n)\) time. Consequently, the overall time complexity is \(\Theta(n\log n)\).</p> <p><br/></p> <h4 id="linear-time-solution">Linear Time Solution</h4> <p>Can we achieve a better solution than the one presented earlier? Given that this section is titled <em>linear time solution</em>, you might rightly speculate, <em>“Yes, it’s possible.”</em> But, why is it intuitively reasonable to think about an improvement? Well, a good point is to observe that the BST-based solution can do much more than what is needed. If I ask you: <em>What’s the second largest element in the window?</em> No problem, the second largest element is the predecessor of the maximum and a BST supports also this operation in \(\Theta(\log n)\) time. You would be able to report the top-\(x\) largest or smallest elements in \(\Theta(x + \log n)\) time (How?). This is because the BST is implicitly keeping all the elements of all the windows sorted. The fact that we can do much more than what is requested, it’s an important signal to think that a faster solution could exist. Still, the title of this section is a stronger one.</p> <p>Surprisingly, the better solution uses an elementary data structure: a queue. We require a <em>Double-Ended Queue</em> (Deque), which supports constant time insertion, removal and access at the front and the back of the queue. There are several ways to implement a deque. The easiest (but not the fastest) way is probably with a bidirectional list.</p> <p>The algorithm starts with an empty deque \(Q\) and with the window \(W\) that covers the positions in the range \(\langle -k, -1 \rangle\). That is, the window starts before the beginning of the array \(A\). Then, we start sliding the window one position at a time and remove/insert elements from \(Q\). We claim that the front of \(Q\) will be the element to report.</p> <p>More precisely, we repeat \(n\) times the following steps.</p> <ul> <li>Move the window one position to the right</li> <li>Remove from the head of \(Q\) the elements that are no longer in the window</li> <li>Insert the new element from the tail of \(Q\) and remove all the elements above it until we find a larger element</li> <li>Report the head of \(Q\) as the maximum in the current window</li> </ul> <p>The implementation of the above solution is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">linear</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="p">{</span>
            <span class="c1">// more idiomatic while let Some(&amp;(p,_)) = q.front()</span>
            <span class="n">q</span><span class="nf">.pop_front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="correctness">Correctness</h5> <p>Let’s prove the correctness of this solution. Looking at the running example below we enthusiastically think: <em>“it could work”</em> <a href="https://www.youtube.com/watch?v=4An1BrG2u_4">cit.</a> Why?</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/swm/example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A running example of the linear time solution with k=3. The deque stores a pair of values: a position in the array and the value at that position. </div> <p>We first observe that <em>the elements in \(Q\) are always sorted in decreasing order</em>. This can be proved by induction on the number of iterations. The claim is true for the initial \(Q\) as it is empty. Given the queue after \(i\) iterations, by hypothesis, it is sorted. The current iteration will only remove elements (no change in the ordering of the remaining elements) or insert the current element \(A[i+1]\) as the tail of the queue just below the first element which is larger than it (if any). Thus, the queue remains sorted.</p> <p>The sortedness of \(Q\) is a nice starting point for proving the correctness but it’s not enough. We need now to introduce the definition of <em>right leader</em>s of the window to show that the largest element within the current window is at the top of the queue. Given a window, an element is called a right leader if and only if the element is larger than any other element of the window at its right.</p> <p>As an example, consider the window of size \(5\) below.</p> <figure> <picture> <img src="/rossano/assets/img/swm/leaders_example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The right leaders of this window are drawn in red.</p> <p>We are now ready to prove a nice property of the elements in \(Q\): <em>At every iteration, \(Q\) contains all and only the right leaders of the current window</em>.</p> <p>This is quite easy to see. Firstly, any right leader cannot be removed from \(Q\) as all the subsequent elements are smaller than it. Secondly, any non-right leader will be removed as soon as the next right leader enters \(Q\). Finally, any element outside the window cannot be in \(Q\). By contradiction, let us assume that \(Q\) contains one such element, say \(a\). Let \(r\) be the largest right leader. On the one hand, \(a\) cannot be smaller than or equal to \(r\), otherwise \(a\) would be removed when inserting \(r\) in \(Q\). On the other hand, \(a\) cannot be larger than \(r\), otherwise, it would be in front of \(Q\) and removed by the first inner loop.</p> <p>We derive the correctness of the algorithm by combining the sortedness of \(Q\) with the fact that the largest right leader is the element to report.</p> <p><br/></p> <h5 id="time-complexity">Time Complexity</h5> <p>Let us show that the algorithm runs in linear time.</p> <p>We first use the standard approach to analyze an algorithm. We have a loop that is repeated \(n\) times. What’s the cost of an iteration? Looking at the implementation it should be clear that its cost is dominated by the cost (and, thus, number) of pop operations. However, in a certain iteration, we may pop out all the elements in the deque. As far as we know there may be up to \(n\) elements in the deque and, thus, an iteration costs \(O(n)\) time. So, the best we can conclude is that the algorithm runs in \(O(n^2)\) time. Can’t go too far with this kind of analysis!</p> <p>In fact, there may indeed exist very costly iterations, but they are greatly amortized by many very cheap ones. Indeed, the overall number of pop operations cannot be larger than \(n\) as any element is not considered anymore by the algorithm as soon as it is removed from \(Q\). Each of them costs constant time and, thus, the algorithm runs in linear time.</p> <p><br/></p> <h4 id="next-larger-element">Next Larger Element</h4> <p>As an useful exercise, you could try to adapt the previous solution to solve the <em>Next Larger Element</em> problem, which is as follows.</p> <p><em>Given an array \(A[0,n-1]\) having distinct elements, the goal is to find the next greater element for each element of the array in order of their appearance in the array.</em>  </p>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[The Sliding Window Maximum problem is a classic algorithmic challenge that involves processing an array in a sliding window fashion. The goal is to find the maximum element within a fixed-size window as it moves through the array. In this notes, we describe several possible solutions to this problem and their implementations in Rust.]]></summary></entry></feed>