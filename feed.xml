<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://pages.di.unipi.it/rossano/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pages.di.unipi.it/rossano/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-10-04T18:04:25+00:00</updated><id>https://pages.di.unipi.it/rossano/feed.xml</id><subtitle>My personal Web Page </subtitle><entry><title type="html">Sweep Line Algorithm</title><link href="https://pages.di.unipi.it/rossano/blog/2023/sweepline/" rel="alternate" type="text/html" title="Sweep Line Algorithm"/><published>2023-10-04T04:01:00+00:00</published><updated>2023-10-04T04:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/sweepline</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/sweepline/"><![CDATA[<p>The <em>Sweep Line Algorithm</em> is an algorithmic paradigm used to solve a lot of problems in computational geometry efficiently. The sweep line algorithm can be used to solve problems on a line or on a plane.</p> <p>Let’s start the description of this paradigm with a problem on a line.</p> <p><br/></p> <h4 id="maximum-number-of-overlapping-intervals">Maximum number of overlapping intervals</h4> <p><em>We are given a set of \(n\) intervals \([s_i, e_i]\) on a line.</em></p> <p><em>We say that two intervals \([s_i, e_i]\) and \([s_j, e_j]\) overlaps if and only if their intersection is not empty, i.e., if there exist at least a point \(x\) belonging to both intervals.</em></p> <p><em>The goal is to compute the maximum number of overlapping intervals.</em></p> <p>For example, consider the set of intevals in the figure.</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>In this example, we have a set of \(10\) intervals. The maximum number of overlapping intervals is \(5\) (at position \(4\)).</p> <p>The sweep line algorithm employs an imaginary <em>vertical line</em> sweeping over the x-axis. As it progresses, we maintain a running solution to the problem at hand. The solution is updated when the vertical line reaches certain key points where some <em>event</em> happen. The type of the event tells us how to update the current solution.</p> <p>To apply this paradigm to our problem, we let the sweep line move from left to right and stop at the beginning or the end of the intervals. These are the important points at which an event occurs: new intervals start or end. We also maintain a counter which keeps track of the number of intervals that are currently intersecting the sweep line, along with the maximum value reached by the counter so far. For each point, we first add to the counter the number of intervals that begin at that point, and then we subtract the number of intervals that end at that point.”</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/SweepLine/MaxIntervalOverlaps_sweep.svg" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <p>Note that the sweep line touches only points on the x-axis where an event occurs. For example, points $1$ and $6$ are not taken into consideration. This is important because the number of considered points, and thus the time complexity, is proportional to the number of intervals and not to the size of the x-axis.</p> <p>Here is a Rust implementation. We represent each interesting point as a pair consisting of the point and the kind, which is either <code class="language-plaintext highlighter-rouge">begin</code> or <code class="language-plaintext highlighter-rouge">end</code>. Then, we sort the vector of pairs in increasing order. Finally, we compute every state of the counter and its largest value. The correctness of the solution is based on a specific detail: since <code class="language-plaintext highlighter-rouge">begin</code> is considered smaller than <code class="language-plaintext highlighter-rouge">end</code>, if two points are the same, we first have pairs with <code class="language-plaintext highlighter-rouge">begin</code> and then pairs with <code class="language-plaintext highlighter-rouge">end</code>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[derive(PartialOrd,</span> <span class="nd">Ord,</span> <span class="nd">PartialEq,</span> <span class="nd">Eq,</span> <span class="nd">Debug)]</span>
<span class="k">enum</span> <span class="n">PointKind</span> <span class="p">{</span>
    <span class="n">Begin</span><span class="p">,</span>
    <span class="n">End</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">max_overlapping</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)])</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">pairs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.map</span><span class="p">(|</span><span class="o">&amp;</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">e</span><span class="p">)|</span> <span class="p">[(</span><span class="n">b</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">Begin</span><span class="p">),</span> <span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">End</span><span class="p">)])</span>
        <span class="nf">.flatten</span><span class="p">()</span>
        <span class="nf">.collect</span><span class="p">();</span>

    <span class="n">pairs</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="n">pairs</span>
        <span class="nf">.into_iter</span><span class="p">()</span>
        <span class="nf">.scan</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">counter</span><span class="p">,</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">kind</span><span class="p">)|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="nn">PointKind</span><span class="p">::</span><span class="n">Begin</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">counter</span> <span class="o">-=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="nf">Some</span><span class="p">(</span><span class="o">*</span><span class="n">counter</span><span class="p">)</span>
        <span class="p">})</span>
        <span class="nf">.max</span><span class="p">()</span>
        <span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="closest-pair-of-points">Closest Pair of Points</h4> <p>In the second problem we use the sweep line paradigm on a set of 2D points.</p> <p><em>We are given a set of $n$ points in the plane.</em></p> <p><em>The goal is to find the closest pair of points in the set. The distance between two points \((x_1, y_1)\) and \((x_2,y_2)\) is the Euclidian distance \(d((x_1,y_1), (x_2,y_2)) = \sqrt((x_1-x_2)^2 +(y_1-y_2)^2)\).</em></p> <p>We start by sorting the points in increasing order of their x-coordinate. We keep track of the shortest distance \(\delta\) seen so far. Initialy \(\delta\) is the distance between an arbitrary pair of points. We use a vertical sweep line to iterate through them, trying to improve the current shortest distance $\delta$. When we process the point $p=(x,y)$, we consider the window with the y-coordinates of all points with x-coordinate in the interval $[x-\delta, x]$. This is because any point with a smaller x-coordinate has a distance with $p$ which is surely larger than $\delta$. Furthermore, by a similar argument, we can consider only point with y-coordinate in the range $[y-\delta, y+\delta]$.</p> <p>Observe that each point is inserted and removed from the set at most once, so the algorithm runs in $\Theta(n\log n)$ time.</p> <ul> <li>[https://en.wikipedia.org/wiki/Sweep_line_algorithm]</li> <li>[https://leetcode.com/discuss/study-guide/2166045/line-sweep-algorithms]</li> <li>[https://www.geeksforgeeks.org/closest-pair-of-points-using-sweep-line-algorithm/]</li> <li>[https://www.youtube.com/watch?v=tgQ3nfemjjQ&amp;t=2474s]</li> <li>[https://usaco.guide/plat/sweep-line?lang=cpp]</li> </ul> <h4 id="exercises">Exercises</h4> <ul> <li><a href="https://leetcode.com/problems/check-if-all-the-integers-in-a-range-are-covered/">Check if all the integers in a range are covered</a></li> </ul>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[Notes for the course Competitive Programming and Contests at University of Pisa]]></summary></entry><entry><title type="html">Tree Travelsals in Rust</title><link href="https://pages.di.unipi.it/rossano/blog/2023/handson12324/" rel="alternate" type="text/html" title="Tree Travelsals in Rust"/><published>2023-10-03T07:01:00+00:00</published><updated>2023-10-03T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/handson12324</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/handson12324/"><![CDATA[<p>This is the text of first hands-on of the the course <a href="competitive/"><em>Competitive Programming and Contests</em></a> at University of Pisa in the accademic year 2023-24.</p> <p>The objective of this hands-on is to implement recursive traversals of a binary tree in Rust. These exercises are valuable for preparing for coding interviews and are worth attempting even if you are not enrolled in the course.</p> <p><br/></p> <h4 id="basic-binary-tree-implementation">Basic Binary Tree Implementation</h4> <p>Let’s begin by describing a basic binary tree implementation in Rust.</p> <p>In our implementation, a node is represented as a struct with three fields: the <code class="language-plaintext highlighter-rouge">key</code> of the node, and the ids of its <code class="language-plaintext highlighter-rouge">id_left</code> and <code class="language-plaintext highlighter-rouge">id_right</code> children. We represent the entire tree using a vector of <code class="language-plaintext highlighter-rouge">Node</code>s. Each node is implicitly assigned an ID that corresponds to its position in the vector.</p> <p>Therefore, a node is defined as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span>
    <span class="n">id_left</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">id_right</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Node</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">,</span>
            <span class="n">id_left</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
            <span class="n">id_right</span><span class="p">:</span> <span class="nb">None</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>We have chosen to use <code class="language-plaintext highlighter-rouge">u32</code> as the data type for the <code class="language-plaintext highlighter-rouge">key</code>. Implementing a generic version of the <code class="language-plaintext highlighter-rouge">Node&lt;T&gt;</code> structure is left as an exercise, albeit potentially quite boring one. Both <code class="language-plaintext highlighter-rouge">id_left</code> and <code class="language-plaintext highlighter-rouge">id_right</code> are of type <code class="language-plaintext highlighter-rouge">Option&lt;usize&gt;</code> and store the IDs of the left and right children of the node, respectively. If a child does not exist, the corresponding ID is set to <code class="language-plaintext highlighter-rouge">None</code>.</p> <p>To create a node, you can use the <code class="language-plaintext highlighter-rouge">new</code> function and specify its <code class="language-plaintext highlighter-rouge">key</code>. The newly created node is considered a leaf and, thus, both children are <code class="language-plaintext highlighter-rouge">None</code>.</p> <p>Now, we are prepared to define the struct <code class="language-plaintext highlighter-rouge">Tree</code>, which is just a vector of nodes.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="n">nodes</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div> <p>In our implementation, we have chosen not to allow empty trees. This simplifies the code a little bit. However, it’s easy to reverse this decision if necessary.</p> <p>You can create a new tree using the <code class="language-plaintext highlighter-rouge">with_root(key: u32)</code> function, which initializes a new tree with a root having the specified <code class="language-plaintext highlighter-rouge">key</code>. The ID of the root node is always <code class="language-plaintext highlighter-rouge">0</code>.</p> <p>We have also decided to restrict operations to only insertions of new nodes; that is, deletions or modifications of existing nodes are not allowed. This limitation aligns with our objectives, as our primary focus is on tree traversal.</p> <p>To insert a new node, you can use the <code class="language-plaintext highlighter-rouge">add_node</code> method. When adding a new node, you need to specify its <code class="language-plaintext highlighter-rouge">parent_id</code>, its <code class="language-plaintext highlighter-rouge">key</code>, and a boolean value, <code class="language-plaintext highlighter-rouge">is_left</code>, which indicates whether the node should be the left or right child of its parent. The method panics if the <code class="language-plaintext highlighter-rouge">parent_id</code> is invalid or if the parent node has already assigned the child we are trying to insert.</p> <p>The implementation of a tree is as follows.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">impl</span> <span class="n">Tree</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">with_root</span><span class="p">(</span><span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="k">Self</span> <span class="p">{</span>
        <span class="k">Self</span> <span class="p">{</span>
            <span class="n">nodes</span><span class="p">:</span> <span class="nd">vec!</span><span class="p">[</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">)],</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="cd">/// Adds a child to the node with `parent_id` and returns the id of the new node. </span>
    <span class="cd">/// The new node has the specified `key`. The new node is the left  child of the  </span>
    <span class="cd">/// node `parent_id` iff `is_left` is `true`, the right child otherwise.</span>
    <span class="cd">///</span>
    <span class="cd">/// # Panics</span>
    <span class="cd">/// Panics if the `parent_id` does not exist, or if the node `parent_id ` has  </span>
    <span class="cd">/// the child already set.</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">add_node</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">parent_id</span><span class="p">:</span> <span class="nb">usize</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">u32</span><span class="p">,</span> <span class="n">is_left</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">usize</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span>
            <span class="n">parent_id</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">(),</span>
            <span class="s">"Parent node id does not exist"</span>
        <span class="p">);</span>
        <span class="k">if</span> <span class="n">is_left</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_left</span> <span class="o">==</span> <span class="nb">None</span><span class="p">,</span>
                <span class="s">"Parent node has the left child already set"</span>
            <span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">assert!</span><span class="p">(</span>
                <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_right</span> <span class="o">==</span> <span class="nb">None</span><span class="p">,</span>
                <span class="s">"Parent node has the right child already set"</span>
            <span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">child_id</span> <span class="o">=</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">();</span>
        <span class="k">self</span><span class="py">.nodes</span><span class="nf">.push</span><span class="p">(</span><span class="nn">Node</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">key</span><span class="p">));</span>

        <span class="k">let</span> <span class="n">child</span> <span class="o">=</span> <span class="k">if</span> <span class="n">is_left</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_left</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">parent_id</span><span class="p">]</span><span class="py">.id_right</span>
        <span class="p">};</span>

        <span class="o">*</span><span class="n">child</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">child_id</span><span class="p">);</span>

        <span class="n">child_id</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="computing-the-sum-of-keys-in-a-binary-tree">Computing the Sum of Keys in a Binary Tree</h4> <p>Let’s implement a simple tree traversal to compute the sum of the keys in a binary tree. This can serve as an example for implementing the solutions for the three exercises below.</p> <p>We will use a recursive function called <code class="language-plaintext highlighter-rouge">rec_sum(&amp;self, node_id: Option&lt;usize&gt;</code>). This function takes a <code class="language-plaintext highlighter-rouge">node_id</code> as input and computes the sum of all the keys in the subtree rooted at <code class="language-plaintext highlighter-rouge">node_id</code>. There are two possibilities. If <code class="language-plaintext highlighter-rouge">node_id</code> is <code class="language-plaintext highlighter-rouge">None</code>, the subtree is empty, and thus, the sum is <code class="language-plaintext highlighter-rouge">0</code>. However, if <code class="language-plaintext highlighter-rouge">node_id</code> refers to a valid node, the sum of the keys is equal to the key of the current node plus the sums of its left and right subtrees. These latter sums are computed recursively.</p> <p>Here is the Rust code. Note that we have the <code class="language-plaintext highlighter-rouge">sum</code> method, which is responsible for calling <code class="language-plaintext highlighter-rouge">rec_sum</code> at the root.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cd">/// Returns the sum of all the keys in the tree</span>
<span class="k">pub</span> <span class="k">fn</span> <span class="nf">sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>
    <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="nf">Some</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="p">}</span>

<span class="cd">/// A private recursive function that computes the sum of</span>
<span class="cd">/// nodes in the subtree rooted at `node_id`.</span>
<span class="k">fn</span> <span class="nf">rec_sum</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">node_id</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u32</span> <span class="p">{</span>

    <span class="k">if</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">(</span><span class="n">id</span><span class="p">)</span> <span class="o">=</span> <span class="n">node_id</span> <span class="p">{</span>
        <span class="nd">assert!</span><span class="p">(</span><span class="n">id</span> <span class="o">&lt;</span> <span class="k">self</span><span class="py">.nodes</span><span class="nf">.len</span><span class="p">(),</span> <span class="s">"Node id is out of range"</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">node</span> <span class="o">=</span> <span class="o">&amp;</span><span class="k">self</span><span class="py">.nodes</span><span class="p">[</span><span class="n">id</span><span class="p">];</span>

        <span class="k">let</span> <span class="n">sum_left</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="n">node</span><span class="py">.id_left</span><span class="p">);</span>
        <span class="k">let</span> <span class="n">sum_right</span> <span class="o">=</span> <span class="k">self</span><span class="nf">.rec_sum</span><span class="p">(</span><span class="n">node</span><span class="py">.id_right</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">sum_left</span> <span class="o">+</span> <span class="n">sum_right</span> <span class="o">+</span> <span class="n">node</span><span class="py">.key</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="mi">0</span>
<span class="p">}</span>
</code></pre></div></div> <p>The code described so far is <a href="/rossano/assets/zip/handson1_2324.zip">here</a>.</p> <p><br/></p> <h4 id="exercise-1">Exercise #1</h4> <p>Write a method to check if the binary tree is a <strong>Binary Search Tree</strong>.</p> <p><br/></p> <h4 id="exercise-2">Exercise #2</h4> <p>Write a method to check if the binary tree is <strong>balanced</strong>.</p> <p>A tree is considered balanced if, for each of its nodes, the heights of its left and right subtrees differ by at most one.</p> <p><br/></p> <h4 id="exercise-3">Exercise #3</h4> <p>Write a method to check if the binary tree is a <strong>max-heap</strong>.</p> <p>A max-heap is a <em>complete</em> binary tree in which every node satisfies the <em>max-heap property</em>. A node satisfies the max-heap property if its key is greater than or equal to the keys of its children.</p> <p><br/></p> <h4 id="test-your-solutions">Test Your Solutions</h4> <p>In the code snippet below, we provide a (limited) set of tests for the <code class="language-plaintext highlighter-rouge">sum</code> method. This code also shows how to construct a binary tree using our implementation. To ensure the robustness of your solutions, we strongly recommend adding a comprehensive suite of tests</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">#[cfg(test)]</span>
<span class="k">mod</span> <span class="n">tests</span> <span class="p">{</span>
    <span class="k">use</span> <span class="k">super</span><span class="p">::</span><span class="o">*</span><span class="p">;</span>

    <span class="nd">#[test]</span>
    <span class="k">fn</span> <span class="nf">test_sum</span><span class="p">()</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">tree</span> <span class="o">=</span> <span class="nn">Tree</span><span class="p">::</span><span class="nf">with_root</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">10</span><span class="p">);</span>

        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// id 1</span>
        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="c1">// id 2</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">37</span><span class="p">);</span>

        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="k">false</span><span class="p">);</span> <span class="c1">// id 3</span>
        <span class="n">tree</span><span class="nf">.add_node</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="k">true</span><span class="p">);</span> <span class="c1">// id 4</span>

        <span class="nd">assert_eq!</span><span class="p">(</span><span class="n">tree</span><span class="nf">.sum</span><span class="p">(),</span> <span class="mi">64</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h4 id="submission">Submission</h4> <p>Submit a file <code class="language-plaintext highlighter-rouge">lib.rs</code> and a file <code class="language-plaintext highlighter-rouge">Handson1_solution_YOUR_NAME.pdf</code> to <a href="mailto:rossano.venturini@gmail.com">rossano.venturini@gmail.com</a> by 19/10/2023.</p> <ul> <li>Source code <code class="language-plaintext highlighter-rouge">lib.rs</code> contains your implementations and a large set of tests.</li> <li>A report <code class="language-plaintext highlighter-rouge">Handson1_solution_YOUR_NAME.pdf</code> that briefly describes your implementations.</li> </ul> <p>Before submitting your solutions,</p> <ul> <li>make sure your implementation successfully passes all the tests.</li> <li>use <code class="language-plaintext highlighter-rouge">cargo fmt</code> to format your code.</li> <li>use <code class="language-plaintext highlighter-rouge">cargo clippy</code> to check your code.</li> <li>use <a href="https://grammarly.com/">Grammarly</a> to improve your English and avoid <a href="https://en.wiktionary.org/wiki/tpyo#English">tpyos</a> :-). There is an <a href="https://marketplace.visualstudio.com/items?itemName=znck.grammarly">extension for vscode</a>.</li> </ul> <p><br/></p> <h4 id="cheating">Cheating</h4> <p><strong>Very important!</strong> You are allowed to discuss verbally solutions with other students, <strong>BUT</strong> you have to implement all the solutions by yourself. Thus, sharing implementations with others is strictly <strong>forbidden</strong>.</p>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[First hands-on of a.y. 23/24 for the course Competitive Programming and Contests at University of Pisa]]></summary></entry><entry><title type="html">Applications of Binary Search</title><link href="https://pages.di.unipi.it/rossano/blog/2023/binarysearch/" rel="alternate" type="text/html" title="Applications of Binary Search"/><published>2023-09-23T07:01:00+00:00</published><updated>2023-09-23T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/binarysearch</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/binarysearch/"><![CDATA[<p>Binary search is undoubtedly one of computer science’s most well-known and fundamental algorithms. This elegant and efficient algorithm searches for a specific key, say \(k\), within a sorted array of \(n\) items, say \(A[0, n-1]\). Binary search repeatedly divides the search range in half until the target element is found or the search range becomes empty, resulting in a time complexity of \(\Theta(\log n)\). This is one of the easiest applications of the <em>Divide-and-Conquer paradigm</em>.</p> <p><br/></p> <h4 id="divide-and-conquer-paradigm">Divide-and-Conquer Paradigm</h4> <p>The divide-and-conquer paradigm tackles a complex problem by breaking it down into smaller, more manageable subproblems of the same type. These subproblems are addressed recursively, and their solutions are combined to yield the solution for the original problem.</p> <p>More precisely, a divide-and-conquer-based algorithm follows three main steps:</p> <ul> <li><strong>Divide</strong>: The initial problem instance is partitioned into smaller subinstances of the same problem.</li> <li><strong>Solve</strong>: These subinstances are then solved recursively. If a subinstance reaches a certain manageable size, a straightforward approach is employed to solve it directly.</li> <li><strong>Combine</strong>: The solutions obtained from the subinstances are combined to obtain the final solution for the original, larger instance of the problem.</li> </ul> <p><br/></p> <h4 id="binary-search-implementation">Binary Search Implementation</h4> <p>We can apply the above paradigm to search for a key in a sorted array of \(n\) elements within \(\Theta(\log n)\) comparisons.</p> <ul> <li><strong>Divide</strong>: The array is divided into two roughly equal halves, centering around the middle element of the array.</li> <li><strong>Solve</strong>: Compare the middle element of the array with the searched key. If the middle element is a match, the search stops successfully. If not, we recursively search for the key only in one of the two halves that may contain based on whether the desired key is greater or lesser than the middle element.</li> <li><strong>Combine</strong>: There is nothing to combine. The algorithm simply reports the final answer.</li> </ul> <p>A Rust implementation of binary search is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span>   <span class="k">=&gt;</span> <span class="k">return</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">),</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span>    <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="nb">None</span>
<span class="p">}</span>
</code></pre></div></div> <p>The generic implementation above works for types that are <a href="https://doc.rust-lang.org/std/cmp/trait.Ord.html"><code class="language-plaintext highlighter-rouge">Ord</code></a>. <code class="language-plaintext highlighter-rouge">Ord</code> is the trait for types that form a total order. The method <code class="language-plaintext highlighter-rouge">cmp</code> returns an <a href="https://doc.rust-lang.org/std/cmp/enum.Ordering.html"><code class="language-plaintext highlighter-rouge">Ordering</code></a> between two elements: In our case, the <code class="language-plaintext highlighter-rouge">key</code> we are looking for and the element in the middle. We use the result of this comparison to check for a match or to move either <code class="language-plaintext highlighter-rouge">low</code> after <code class="language-plaintext highlighter-rouge">middle</code> or <code class="language-plaintext highlighter-rouge">high</code> to <code class="language-plaintext highlighter-rouge">middle</code>. Note that the position <code class="language-plaintext highlighter-rouge">high</code> is not included in the range.</p> <p>It is worth noticing the expression <code class="language-plaintext highlighter-rouge">middle = low + (high - low)/2</code> to compute the position in the middle of the current range. A lot of existing implementations on the net use instead the expression <code class="language-plaintext highlighter-rouge">middle = (low + high) / 2</code>, which is buggy. Indeed, it leads to overflow if <code class="language-plaintext highlighter-rouge">low + high</code> is greater than <code class="language-plaintext highlighter-rouge">usize::MAX</code>.</p> <p>It is also important to observe that when there are multiple occurrences of the searched key, the function returns the position of the first encountered occurrence, not necessarily the first occurrence in the vector. This behavior aligns with the implementation of <a href="https://doc.rust-lang.org/std/vec/struct.Vec.html#method.binary_search">binary search</a> in Rust. However, it is often very useful to report the position of the first occurrence of the searched key. We can obtain this behavior with the following implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="n">binary_search</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Ord</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arr</span><span class="p">:</span> <span class="o">&amp;</span><span class="p">[</span><span class="n">T</span><span class="p">],</span> <span class="n">key</span><span class="p">:</span> <span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">arr</span><span class="nf">.len</span><span class="p">();</span> <span class="c1">// note that high is excluded</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

        <span class="k">match</span> <span class="n">key</span><span class="nf">.cmp</span><span class="p">(</span><span class="o">&amp;</span><span class="n">arr</span><span class="p">[</span><span class="n">middle</span><span class="p">])</span> <span class="p">{</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Equal</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">);</span>
                <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span>
            <span class="p">}</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Less</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
            <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nn">Ordering</span><span class="p">::</span><span class="n">Greater</span> <span class="k">=&gt;</span> <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this implementation, when a match is found, we do not immediately return its position. Instead, we update the <code class="language-plaintext highlighter-rouge">ans</code> variable and set <code class="language-plaintext highlighter-rouge">high</code> to the position of this occurrence. This way, we continue the search in the first half of the array, seeking additional occurrences of the <code class="language-plaintext highlighter-rouge">key</code>. If there are more matches, <code class="language-plaintext highlighter-rouge">ans</code> will be further updated with smaller positions.</p> <p>As a useful exercise you could try to modify the code above to return the smallest position such that the element at that position is greater than or equal to <code class="language-plaintext highlighter-rouge">key</code>. In other word, if the <code class="language-plaintext highlighter-rouge">key</code> is not in the slice, it returns the position of its successor.</p> <p>Instead of implementing the code above, we can find the first (or even the last) occurrence of a key with <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.partition_point">partition_point</a> method of the standard library. This method is even more generic that our code above. Indeed, it returns the index of the partition point in a sorted vector according to any given predicate.</p> <p><br/></p> <h4 id="binary-search-the-answer">Binary Search the Answer</h4> <p>Consider a problem where all the possible candidate answers are restricted to a range of values between certain <code class="language-plaintext highlighter-rouge">low</code> and <code class="language-plaintext highlighter-rouge">high</code> possible answers. In other words, any candidate answer \(x\) falls within the range <code class="language-plaintext highlighter-rouge">[low, high)</code>. We also have a boolean predicate <code class="language-plaintext highlighter-rouge">pred</code> defined on the candidate answers that tells us if an answer is good or not for our aims. Our goal is to find the largest good answer.</p> <p>When no assumptions are made about the predicate, we cannot do better than evaluating the predicate on all the possible answers. So, the number of times we evaluate the predicate is \(\Theta(n)\), where \(n = high-low\) is the number of possible answers.</p> <p>Instead, if the predicate is <strong>monotone</strong>, we can <em>binary search the answer</em> to find it with \(\Theta(\log n)\) evaluations. This strategy is implemented by the generic function below.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">FromPrimitive</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">num</span><span class="p">::</span><span class="n">Num</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">cmp</span><span class="p">::</span><span class="nb">PartialOrd</span><span class="p">;</span>

<span class="k">fn</span> <span class="n">binary_search_range</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">F</span><span class="o">&gt;</span><span class="p">(</span><span class="n">low</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">high</span><span class="p">:</span> <span class="n">T</span><span class="p">,</span> <span class="n">pred</span><span class="p">:</span> <span class="n">F</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="k">where</span>
    <span class="n">T</span><span class="p">:</span> <span class="n">Num</span> <span class="o">+</span> <span class="nb">PartialOrd</span> <span class="o">+</span> <span class="n">FromPrimitive</span> <span class="o">+</span> <span class="nb">Copy</span><span class="p">,</span>
    <span class="n">F</span><span class="p">:</span> <span class="nf">Fn</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">bool</span><span class="p">,</span>
<span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">low</span> <span class="o">=</span> <span class="n">low</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">high</span> <span class="o">=</span> <span class="n">high</span><span class="p">;</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">ans</span> <span class="o">=</span> <span class="nb">None</span><span class="p">;</span>

    <span class="k">while</span> <span class="n">low</span> <span class="o">&lt;</span> <span class="n">high</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">low</span> <span class="o">+</span> <span class="p">(</span><span class="n">high</span> <span class="o">-</span> <span class="n">low</span><span class="p">)</span> <span class="o">/</span> <span class="nn">FromPrimitive</span><span class="p">::</span><span class="nf">from_u64</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">match</span> <span class="nf">pred</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">true</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="n">low</span> <span class="o">=</span> <span class="n">middle</span> <span class="o">+</span> <span class="nn">T</span><span class="p">::</span><span class="nf">one</span><span class="p">();</span>
                <span class="n">ans</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">middle</span><span class="p">)</span>
            <span class="p">}</span>
            <span class="k">false</span> <span class="k">=&gt;</span> <span class="n">high</span> <span class="o">=</span> <span class="n">middle</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">ans</span>
<span class="p">}</span>
</code></pre></div></div> <p>The function takes the extremes (of type <code class="language-plaintext highlighter-rouge">T</code>) of the range and the predicate as an argument. We use the external crate <a href="https://docs.rs/num/latest/num/">Num</a> to require some basic arithmetic operations for type <code class="language-plaintext highlighter-rouge">T</code>. The function returns the largest element of the range satisfying the predicate, or <code class="language-plaintext highlighter-rouge">None</code> if there is no such element.</p> <p>Let’s use this function to solve problems.</p> <p><br/></p> <h5 id="sqrt">Sqrt</h5> <p>An example is the problem <em><a href="https://leetcode.com/problems/sqrtx/">Sqrt</a></em>.</p> <p><em>We are given a non-negative integer \(v\) and we want to compute the square root of \(v\) rounded down to the nearest integer.</em></p> <p>The possible answers are in \([0, v]\). For each candidate answer \(x\), the predicate is \(p(x) = x^2 &lt;= v\). Thus, we can find the result in \(\Theta(\log v)\) time.</p> <p>Thus, a one-line solution is</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">sqrt</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="nb">u64</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">u64</span> <span class="p">{</span>
    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">|</span><span class="n">x</span><span class="p">|</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">v</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="social-distancing">Social Distancing</h5> <p>Let’s consider <a href="http://www.usaco.org/index.php?page=viewproblem2&amp;cpid=1038">another problem</a>.</p> <p><em>We have a sequence of \(n\) mutually-disjoint intervals. The extremes of each interval are non-negative integers. We aim to find \(c\) integer points within the intervals such that the smallest distance \(d\) between consecutive selected points is <strong>maximized</strong>.</em></p> <p>Guess what? A solution to this problem binary searches the answer, the target distance \(d\). Why is this possible? If a certain distance is feasible (i.e., there exists a selection of points at that distance), then any smaller distance is also feasible. Thus, the feasibility is a monotone boolean predicate that we can use to binary search the answer.</p> <p>As the candidate answers range from \(1\) to \(l\), where \(l\) is the overall length of the intervals, the solution takes \(\Theta(\log l)\) evaluations of the predicate.</p> <p>What’s the cost of evaluating the predicate? Well, we first sort the intervals. Now, we can evaluate any candidate distance \(d'\) by scanning the sorted intervals from left to right. First, we select the left extreme of the first interval as the first point. Then, we move over the intervals, and we choose greedly the first point, which is at a distance at least \(d'\) from the previous one. Thus, an evaluation of the predicate takes \(\Theta(n)\) time.</p> <p>The overall running time is \(\Theta(n\log l)\).</p> <p>A Rust implementation of this strategy is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">select_intervals</span><span class="p">(</span><span class="n">intervals</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">usize</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="p">{</span>

    <span class="k">let</span> <span class="n">l</span> <span class="o">=</span> <span class="n">intervals</span>
        <span class="nf">.iter</span><span class="p">()</span>
        <span class="nf">.fold</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">|</span><span class="n">acc</span><span class="p">,</span> <span class="n">interval</span><span class="p">|</span> <span class="n">acc</span> <span class="o">+</span> <span class="n">interval</span><span class="na">.1</span> <span class="o">-</span> <span class="n">interval</span><span class="na">.0</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span> <span class="c1">// overall length</span>

    <span class="k">if</span> <span class="n">l</span> <span class="o">&lt;</span> <span class="n">c</span> <span class="p">{</span>
        <span class="c1">// there is no solution</span>
        <span class="k">return</span> <span class="nb">None</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">intervals</span><span class="nf">.sort_unstable</span><span class="p">();</span>

    <span class="c1">// A closure implements our predicate</span>
    <span class="k">let</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">|</span><span class="n">d</span><span class="p">:</span> <span class="nb">usize</span><span class="p">|</span> <span class="k">-&gt;</span> <span class="nb">bool</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">last_selected</span> <span class="o">=</span> <span class="n">intervals</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="na">.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="o">&amp;</span><span class="n">interval</span> <span class="k">in</span> <span class="n">intervals</span><span class="nf">.iter</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">while</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">interval</span><span class="na">.1</span> <span class="p">{</span>
                <span class="n">last_selected</span> <span class="o">=</span> <span class="n">interval</span><span class="na">.0</span><span class="nf">.max</span><span class="p">(</span><span class="n">last_selected</span> <span class="o">+</span> <span class="n">d</span><span class="p">);</span>
                <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">cnt</span> <span class="o">&gt;=</span> <span class="n">c</span>
    <span class="p">};</span>

    <span class="nf">binary_search_range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">pred</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="other-problems">Other Problems</h5> <ul> <li><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/">Find First and Last Position of Element in Sorted Array</a></li> <li><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/">Find the minimum in a rotated sorted array</a></li> <li><a href="https://leetcode.com/problems/find-peak-element/">Search for a peak in an (unsorted) array</a></li> </ul>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[Notes for the course Competitive Programming and Contests at University of Pisa]]></summary></entry><entry><title type="html">Sliding Window Maximum</title><link href="https://pages.di.unipi.it/rossano/blog/2023/swm/" rel="alternate" type="text/html" title="Sliding Window Maximum"/><published>2023-09-10T07:01:00+00:00</published><updated>2023-09-10T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/swm</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/swm/"><![CDATA[<p>The <em>Sliding Window Maximum</em> problem is as follows.</p> <p><em>Given an array \(A[0,n-1]\) and an integer \(k\), the goal is to find the maximum of each subarray (window) of \(A\) of size \(k\).</em></p> <p>The simplest approach to address this problem involves handling each of the \(n-k+1\) windows independently. Within each window, we calculate its maximum by scanning through all its elements, which takes \(\Theta(k)\) time. Consequently, this straightforward brute force solution operates in \(\Theta(nk)\) time.</p> <p>Here is a Rust implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.len</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">current_slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">max_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_slice</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>A more elegant one-line implementation uses <a href="https://learning-rust.github.io/docs/combinators/">combinators</a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">v</span><span class="nf">.windows</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div> <p>The inefficiency of this solution stems from the fact that when calculating the maximum of a window, we disregard all the computations previously performed to determine the maxima of the preceding windows.</p> <p><br/></p> <h4 id="bst-based-solution">BST-based Solution</h4> <p>Enhancing the brute force solution above entails leveraging a data structure to efficiently handle the next window while capitalizing on the progress made in processing the preceding window. The design of a faster solution begins with two straightforward observations:</p> <p>Firstly, we can represent the elements within a window as a multiset \({\cal M}\) of size \(k\). In this representation, the result for the window is essentially the largest element contained within this multiset.</p> <p>Secondly, when we transition from one window to the next, only two elements change: the first element of the first window exits from the scene, and the last element of the second one enters. Consequently, we can derive the multiset of the new window from the multiset of the previous window by simply adding one element and removing another one.</p> <p>Hence, we require a data structure capable of performing three crucial operations on a (multi)set: inserting a new element, deleting an arbitrary element, and efficiently retrieving the maximum element within the multiset. By employing such a versatile data structure, we can seamlessly move the window across the array while efficiently updating and querying the multiset to calculate the desired results. Now the question is: What’s the best data structure supporting these operations? A <em>Balanced Binary Search Tree</em> (BBST) supports any of these operations in \(\Theta(\log |{\cal M}|)\), where \(|{\cal M}|\) is the number of elements in the multiset (and it is optimal in the comparison model). This way, we can solve the problem in \(\Theta(n \log k)\) time.</p> <p>A Rust implementation of this strategy is as follows. Here we use <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html">BTreeSet</a>. A <code class="language-plaintext highlighter-rouge">BTreeSet</code> is BST-like data structure that represents a set of unique, ordered elements. It provides efficient implmementation of insertion (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.insert">insert()</a>), deletion (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.remove">remove()</a>), and maximum (<a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html#method.last">last()</a>) operations. The only issue to deal with is that a <code class="language-plaintext highlighter-rouge">BTreeSet</code> does not store repeated values. For this reason, we store elements together with their positions. This way, every element in the array is inseerted as a unique pair in the <code class="language-plaintext highlighter-rouge">BTreeSet</code>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeSet</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">bst</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">max_sf</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">set</span><span class="nf">.insert</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>

        <span class="n">max_sf</span> <span class="o">=</span> <span class="n">max_sf</span><span class="nf">.max</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// keep track of the max so far to avoid a costly query to the set</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="p">{</span>
            <span class="n">set</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">));</span>
            <span class="k">if</span> <span class="n">max_sf</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">max_sf</span> <span class="o">=</span> <span class="n">set</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_sf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>In this implementation we’ve incorporated a straightforward optimization to reduce the number of calls to <code class="language-plaintext highlighter-rouge">set.last()</code>. We keep track of the maximum element encountered so far, denoted as <code class="language-plaintext highlighter-rouge">max_sf</code>. We only call <code class="language-plaintext highlighter-rouge">set.last()</code> when <code class="language-plaintext highlighter-rouge">max_sƒ</code> might be invalidated by a delition of an element equals to <code class="language-plaintext highlighter-rouge">max_sƒ</code>.</p> <p><br/></p> <h4 id="heap-based-solution">Heap-based Solution</h4> <p>It’s worth noting an alternative solution that, theoretically, is slightly less efficient than the previous one (i.e., \(\Theta(n\log n)\) instead of \(\Theta(n\log k)\)). However, in practice, this alternative solution often proves to be faster.</p> <p>As we are talking about maximum, the immediate choice that springs to mind is the priority queue, with its most renowned manifestation being the <em>(max-)heap</em>. A max-heap stores a set \(n\) of keys and supports three operations:</p> <ul> <li>Insert an element in the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.push">push</a>).</li> <li>Report the maximum element in the max-heap. The operation takes \(O(1)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.peek">peek</a>).</li> <li>Extract the maximum element from the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.pop">pop</a>).</li> </ul> <p>We can solve the sliding window maximum problem by employing a max-heap and scanning the array from left to right. Here’s how it works.</p> <p>Initially, we populate a max-heap with the first \(k\) elements of \(A\) along with their respective positions. This gives us the maximum within the initial window, which is essentially the maximum provided by the heap.</p> <p>As we move on to process the remaining elements of \(A\) one by one, we insert each current element into the heap alongside its position. We then request the heap to provide us with the current maximum. However, it’s important to note that this reported maximum element might fall outside the current window’s boundaries. To address this, we continuously extract elements from the heap until the reported maximum is within the constraints of the current window.</p> <p>A Rust implementation of this strategy is the following one.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">heap</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">heap</span><span class="nf">.pop</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>It’s worth noting that with this approach, there are a total of \(n\) insertions and at most \(n\) extractions of the maximum in the heap. Since the maximum number of elements present in the heap at any given time is up to \(n\), each of these operations takes \(\Theta(\log n)\) time. Consequently, the overall time complexity is \(\Theta(n\log n)\).</p> <p><br/></p> <h4 id="linear-time-solution">Linear Time Solution</h4> <p>Can we achieve a better solution than the one presented earlier? Given that this section is titled <em>linear time solution</em>, you might rightly speculate, <em>“Yes, it’s possible.”</em> But, why is it intuitively reasonable to think about an improvement? Well, a good point is to observe that the BST-based solution can do much more than what is needed. If I ask you: <em>What’s the second largest element in the window?</em> No problem, the second largest element is the predecessor of the maximum and a BST supports also this operation in \(\Theta(\log n)\) time. You would be able to report the top-\(x\) largest or smallest elements in \(\Theta(x + \log n)\) time (How?). This is because the BST is implicitly keeping all the elements of all the windows sorted. The fact that we can do much more than what is requested, it’s an important signal to think that a faster solution could exist. Still, the title of this section is a stronger one.</p> <p>Surprisingly, the better solution uses an elementary data structure: a queue. We require a <em>Double-Ended Queue</em> (Deque), which supports constant time insertion, removal and access at the front and the back of the queue. There are several ways to implement a deque. The easiest (but not the fastest) way is probably with a bidirectional list.</p> <p>The algorithm starts with an empty deque \(Q\) and with the window \(W\) that covers the positions in the range \(\langle -k, -1 \rangle\). That is, the window starts before the beginning of the array \(A\). Then, we start sliding the window one position at a time and remove/insert elements from \(Q\). We claim that the front of \(Q\) will be the element to report.</p> <p>More precisely, we repeat \(n\) times the following steps.</p> <ul> <li>Move the window one position to the right</li> <li>Remove from the head of \(Q\) the elements that are no longer in the window</li> <li>Insert the new element from the tail of \(Q\) and remove all the elements above it until we find a larger element</li> <li>Report the head of \(Q\) as the maximum in the current window</li> </ul> <p>The implementation of the above solution is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">linear</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&gt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nn">Vec</span><span class="p">::</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="p">{</span>
            <span class="c1">// more idiomatic while let Some(&amp;(p,_)) = q.front()</span>
            <span class="n">q</span><span class="nf">.pop_front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p><br/></p> <h5 id="correctness">Correctness</h5> <p>Let’s prove the correctness of this solution. Looking at the running example below we enthusiastically think: <em>“it could work”</em> <a href="https://www.youtube.com/watch?v=4An1BrG2u_4">cit.</a> Why?</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/swm/example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A running example of the linear time solution with k=3. The deque stores a pair of values: a position in the array and the value at that position. </div> <p>We first observe that <em>the elements in \(Q\) are always sorted in decreasing order</em>. This can be proved by induction on the number of iterations. The claim is true for the initial \(Q\) as it is empty. Given the queue after \(i\) iterations, by hypothesis, it is sorted. The current iteration will only remove elements (no change in the ordering of the remaining elements) or insert the current element \(A[i+1]\) as the tail of the queue just below the first element which is larger than it (if any). Thus, the queue remains sorted.</p> <p>The sortedness of \(Q\) is a nice starting point for proving the correctness but it’s not enough. We need now to introduce the definition of <em>right leader</em>s of the window to show that the largest element within the current window is at the top of the queue. Given a window, an element is called a right leader if and only if the element is larger than any other element of the window at its right.</p> <p>As an example, consider the window of size \(5\) below.</p> <figure> <picture> <img src="/rossano/assets/img/swm/leaders_example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The right leaders of this window are drawn in red.</p> <p>We are now ready to prove a nice property of the elements in \(Q\): <em>At every iteration, \(Q\) contains all and only the right leaders of the current window</em>.</p> <p>This is quite easy to see. Firstly, any right leader cannot be removed from \(Q\) as all the subsequent elements are smaller than it. Secondly, any non-right leader will be removed as soon as the next right leader enters \(Q\). Finally, any element outside the window cannot be in \(Q\). By contradiction, let us assume that \(Q\) contains one such element, say \(a\). Let \(r\) be the largest right leader. On the one hand, \(a\) cannot be smaller than or equal to \(r\), otherwise \(a\) would be removed when inserting \(r\) in \(Q\). On the other hand, \(a\) cannot be larger than \(r\), otherwise, it would be in front of \(Q\) and removed by the first inner loop.</p> <p>We derive the correctness of the algorithm by combining the sortedness of \(Q\) with the fact that the largest right leader is the element to report.</p> <p><br/></p> <h5 id="time-complexity">Time Complexity</h5> <p>Let us show that the algorithm runs in linear time.</p> <p>We first use the standard approach to analyze an algorithm. We have a loop that is repeated \(n\) times. What’s the cost of an iteration? Looking at the implementation it should be clear that its cost is dominated by the cost (and, thus, number) of pop operations. However, in a certain iteration, we may pop out all the elements in the deque. As far as we know there may be up to \(n\) elements in the deque and, thus, an iteration costs \(O(n)\) time. So, the best we can conclude is that the algorithm runs in \(O(n^2)\) time. Can’t go too far with this kind of analysis!</p> <p>In fact, there may indeed exist very costly iterations, but they are greatly amortized by many very cheap ones. Indeed, the overall number of pop operations cannot be larger than \(n\) as any element is not considered anymore by the algorithm as soon as it is removed from \(Q\). Each of them costs constant time and, thus, the algorithm runs in linear time.</p> <p><br/></p> <h4 id="next-larger-element">Next Larger Element</h4> <p>As an useful exercise, you could try to adapt the previous solution to solve the <em>Next Larger Element</em> problem, which is as follows.</p> <p><em>Given an array \(A[0,n-1]\) having distinct elements, the goal is to find the next greater element for each element of the array in order of their appearance in the array.</em></p>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[Notes for the course Competitive Programming and Contests at University of Pisa]]></summary></entry></feed>