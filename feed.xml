<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator><link href="https://pages.di.unipi.it/rossano/feed.xml" rel="self" type="application/atom+xml"/><link href="https://pages.di.unipi.it/rossano/" rel="alternate" type="text/html" hreflang="en"/><updated>2023-09-22T02:56:41+00:00</updated><id>https://pages.di.unipi.it/rossano/feed.xml</id><subtitle>My personal Web Page </subtitle><entry><title type="html">Sliding Window Maximum</title><link href="https://pages.di.unipi.it/rossano/blog/2023/swm/" rel="alternate" type="text/html" title="Sliding Window Maximum"/><published>2023-09-10T07:01:00+00:00</published><updated>2023-09-10T07:01:00+00:00</updated><id>https://pages.di.unipi.it/rossano/blog/2023/swm</id><content type="html" xml:base="https://pages.di.unipi.it/rossano/blog/2023/swm/"><![CDATA[<p>The <em>Sliding window maximum</em> problem is as follows.</p> <p><em>Given an array \(A[0,n-1]\) and an integer \(k\), the goal is to find the maximum of each subarray (window) of \(A\) of size \(k\).</em></p> <p>The simplest approach to address this problem involves handling each of the \(n-k+1\) windows independently. Within each window, we calculate its maximum by scanning through all its elements, which takes \(\Theta(k)\) time. Consequently, this straightforward brute force solution operates in \(\Theta(nk)\) time.</p> <p>Here is a Rust implementation.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">v</span><span class="nf">.len</span><span class="p">();</span>
    
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">current_slice</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="o">..</span><span class="n">i</span> <span class="o">+</span> <span class="n">k</span><span class="p">];</span>
        <span class="k">let</span> <span class="n">max_value</span> <span class="o">=</span> <span class="o">*</span><span class="n">current_slice</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_value</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>A more elegant one-line implementation uses <a href="https://learning-rust.github.io/docs/combinators/">combinators</a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">brute_force</span><span class="p">(</span><span class="n">v</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">v</span><span class="nf">.windows</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="nf">.map</span><span class="p">(|</span><span class="n">w</span><span class="p">|</span> <span class="o">*</span><span class="n">w</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.max</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">())</span><span class="nf">.collect</span><span class="p">()</span>
<span class="p">}</span>

</code></pre></div></div> <p>The inefficiency of this solution stems from the fact that when calculating the maximum of a window, we disregard all the computations previously performed to determine the maxima of the preceding windows.</p> <h4 id="bst-based-solution">BST-based solution</h4> <p>Enhancing the brute force solution above entails leveraging a data structure to efficiently handle the next window while capitalizing on the progress made in processing the preceding window. The design of a faster solution begins with two straightforward observations:</p> <p>Firstly, we can represent the elements within a window as a multiset \({\cal M}\) of size \(k\). In this representation, the result for the window is essentially the largest element contained within this multiset.</p> <p>Secondly, when we transition from one window to the next, only two elements change: the first element of the first window exits from the scene, and the last element of the second one enters. Consequently, we can derive the multiset of the new window from the multiset of the previous window by simply adding one element and removing another one.</p> <p>Hence, we require a data structure capable of performing three crucial operations on a (multi)set: inserting a new element, deleting an arbitrary element, and efficiently retrieving the maximum element within the multiset. By employing such a versatile data structure, we can seamlessly move the window across the array while efficiently updating and querying the multiset to calculate the desired results. Now the question is: What’s the best data structure supporting these operations? A <em>Balanced Binary Search Tree</em> (BBST) supports any of these operations in \(\Theta(\log |{\cal M}|)\), where \(|{\cal M}|\) is the number of elements in the multiset (and it is optimal in the comparison model). This way, we can solve the problem in \(\Theta(n \log k)\) time.</p> <p>A Rust implementation of this strategy is as follows. Here we use <a href="https://doc.rust-lang.org/stable/std/collections/struct.BTreeSet.html">BTreeSet</a>.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BTreeSet</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">bst</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">set</span> <span class="o">=</span> <span class="nn">BTreeSet</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">max_sf</span> <span class="o">=</span> <span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">)</span> <span class="k">in</span> <span class="n">nums</span><span class="nf">.iter</span><span class="p">()</span><span class="nf">.enumerate</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">set</span><span class="nf">.insert</span><span class="p">((</span><span class="n">v</span><span class="p">,</span> <span class="n">i</span><span class="p">));</span>

        <span class="n">max_sf</span> <span class="o">=</span> <span class="n">max_sf</span><span class="nf">.max</span><span class="p">(</span><span class="n">v</span><span class="p">);</span> <span class="c1">// keep track of the max so far to avoid a costly query to the set</span>

        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="p">{</span>
            <span class="n">set</span><span class="nf">.remove</span><span class="p">(</span><span class="o">&amp;</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">],</span> <span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">));</span>
            <span class="k">if</span> <span class="n">max_sf</span> <span class="o">==</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="n">k</span><span class="p">]</span> <span class="p">{</span>
                <span class="n">max_sf</span> <span class="o">=</span> <span class="n">set</span><span class="nf">.last</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">max_sf</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="heap-based-solution">Heap-based solution</h4> <p>It’s worth noting an alternative solution that, theoretically, is slightly less efficient than the previous one (i.e., \(\Theta(n\log n)\) instead of \(\Theta(n\log k)\)). However, in practice, this alternative solution often proves to be faster.</p> <p>As we are talking about maximum, the immediate choice that springs to mind is the priority queue, with its most renowned manifestation being the <em>(max-)heap</em>. A max-heap stores a set \(n\) of keys and supports three operations:</p> <ul> <li>Insert an element in the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.push">push</a>).</li> <li>Report the maximum element in the max-heap. The operation takes \(O(1)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.peek">peek</a>).</li> <li>Extract the maximum element from the max-heap. The operation takes \(O(\log n)\) time. In Rust’s implementation this is called <a href="https://doc.rust-lang.org/stable/std/collections/struct.BinaryHeap.html#method.pop">pop</a>).</li> </ul> <p>We can solve the sliding window maximum problem by employing a max-heap and scanning the array from left to right. Here’s how it works.</p> <p>Initially, we populate a max-heap with the first \(k\) elements of \(A\) along with their respective positions. This gives us the maximum within the initial window, which is essentially the maximum provided by the heap.</p> <p>As we move on to process the remaining elements of \(A\) one by one, we insert each current element into the heap alongside its position. We then request the heap to provide us with the current maximum. However, it’s important to note that this reported maximum element might fall outside the current window’s boundaries. To address this, we continuously extract elements from the heap until the reported maximum is within the constraints of the current window.</p> <p>A Rust implementation of this strategy is the following one.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">BinaryHeap</span><span class="p">;</span>

<span class="k">pub</span> <span class="k">fn</span> <span class="nf">heap</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">heap</span><span class="p">:</span> <span class="n">BinaryHeap</span><span class="o">&lt;</span><span class="p">(</span><span class="nb">i32</span><span class="p">,</span> <span class="nb">usize</span><span class="p">)</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">BinaryHeap</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="n">heap</span><span class="nf">.push</span><span class="p">((</span><span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">));</span>
        <span class="k">while</span> <span class="k">let</span> <span class="nf">Some</span><span class="p">((</span><span class="n">_</span><span class="p">,</span> <span class="n">idx</span><span class="p">))</span> <span class="o">=</span> <span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">if</span> <span class="o">*</span><span class="n">idx</span> <span class="o">&lt;</span> <span class="n">i</span> <span class="o">-</span> <span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">heap</span><span class="nf">.pop</span><span class="p">();</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">heap</span><span class="nf">.peek</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span><span class="na">.0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <p>It’s worth noting that with this approach, there are a total of \(n\) insertions and at most \(n\) extractions of the maximum in the heap. Since the maximum number of elements present in the heap at any given time is up to \(n\), each of these operations takes \(\Theta(\log n)\) time. Consequently, the overall time complexity is \(\Theta(n\log n)\).</p> <h2 id="linear-time-solution">Linear time solution</h2> <p>Can we achieve a better solution than the one presented earlier? Given that this section is titled <em>linear time solution</em>, you might rightly speculate, <em>“Yes, it’s possible.”</em> But, why is it intuitively reasonable to think about an improvement? Well, a good point is to observe that the BST-based solution can do much more than what is needed. If I ask you: <em>What’s the second largest element in the window?</em> No problem, the second largest element is the predecessor of the maximum and a BST supports also this operation in \(\Theta(\log n)\) time. You would be able to report the top-\(x\) largest or smallest elements in \(\Theta(x + \log n)\) time (How?). This is because the BST is implicitly keeping all the elements of all the windows sorted. The fact that we can do much more than what is requested, it’s an important signal to think that a faster solution could exist. Still, the title of this section is a stronger one.</p> <p>Surprisingly, the better solution uses an elementary data structure: a queue. We require a <em>Double-Ended Queue</em> (Deque), which supports constant time insertion, removal and access at the front and the back of the queue. There are several ways to implement a deque. The easiest (but not the fastest) way is probably with a bidirectional list.</p> <p>The algorithm starts with an empty deque \(Q\) and with the window \(W\) that covers the positions in the range \(\langle -k, -1 \rangle\). That is, the window starts before the beginning of the array \(A\). Then, we start sliding the window one position at a time and remove/insert elements from \(Q\). We claim that the front of \(Q\) will be the element to report.</p> <p>More precisely, we repeat \(n\) times the following steps.</p> <ul> <li>Move the window one position to the right</li> <li>Remove from the head of \(Q\) the elements that are no longer in the window</li> <li>Insert the new element from the tail of \(Q\) and remove all the elements above it until we find a larger element</li> <li>Report the head of \(Q\) as the maximum in the current window</li> </ul> <p>The implementation of the above solution is the following.</p> <div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">collections</span><span class="p">::</span><span class="n">VecDeque</span><span class="p">;</span>

<span class="k">fn</span> <span class="nf">linear</span><span class="p">(</span><span class="n">nums</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="nb">usize</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>

    <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="p">{</span> 
        <span class="k">return</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">let</span> <span class="k">mut</span> <span class="n">q</span><span class="p">:</span> <span class="n">VecDeque</span><span class="o">&lt;</span><span class="nb">usize</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">VecDeque</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">n</span> <span class="o">=</span> <span class="n">nums</span><span class="nf">.len</span><span class="p">();</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">maxs</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">i32</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">with_capacity</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">..</span><span class="n">k</span> <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="k">for</span> <span class="n">i</span> <span class="k">in</span> <span class="n">k</span><span class="o">..</span><span class="n">n</span> <span class="p">{</span>
        <span class="k">while</span> <span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()</span> <span class="o">+</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="p">{</span>
            <span class="c1">// more idiomatic while let Some(&amp;(p,_)) = q.front()</span>
            <span class="n">q</span><span class="nf">.pop_front</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">q</span><span class="nf">.is_empty</span><span class="p">())</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.back</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]</span> <span class="p">{</span>
            <span class="n">q</span><span class="nf">.pop_back</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="n">q</span><span class="nf">.push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">maxs</span><span class="nf">.push</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="o">*</span><span class="n">q</span><span class="nf">.front</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">()]);</span>

    <span class="p">}</span>
    <span class="n">maxs</span>
<span class="p">}</span>
</code></pre></div></div> <h4 id="correctness">Correctness</h4> <p>Let’s prove the correctness of this solution. Looking at the running example below we enthusiastically think: <em>“it could work”</em> <a href="https://www.youtube.com/watch?v=4An1BrG2u_4">cit.</a> Why?</p> <div class="row mt-3"> <div class="col-sm mt-3 mt-md-0"> <figure> <picture> <img src="/rossano/assets/img/swm/example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> </div> </div> <div class="caption"> A running example of the linear time solution with k=3. The deque stores a pair of values: a position in the array and the value at that position. </div> <p>We first observe that <em>the elements in \(Q\) are always sorted in decreasing order</em>. This can be proved by induction on the number of iterations. The claim is true for the initial \(Q\) as it is empty. Given the queue after \(i\) iterations, by hypothesis, it is sorted. The current iteration will only remove elements (no change in the ordering of the remaining elements) or insert the current element \(A[i+1]\) as the tail of the queue just below the first element which is larger than it (if any). Thus, the queue remains sorted.</p> <p>The sortedness of \(Q\) is a nice starting point for proving the correctness but it’s not enough. We need now to introduce the definition of <em>right leader</em>s of the window to show that the largest element within the current window is at the top of the queue. Given a window, an element is called a right leader if and only if the element is larger than any other element of the window at its right.</p> <p>As an example, consider the window of size \(5\) below.</p> <figure> <picture> <img src="/rossano/assets/img/swm/leaders_example.png" class="img-fluid rounded z-depth-1" width="auto" height="auto" data-zoomable="" onerror="this.onerror=null; $('.responsive-img-srcset').remove();"/> </picture> </figure> <p>The right leaders of this window are drawn in red.</p> <p>We are now ready to prove a nice property of the elements in \(Q\): <em>At every iteration, \(Q\) contains all and only the right leaders of the current window</em>.</p> <p>This is quite easy to see. Firstly, any right leader cannot be removed from \(Q\) as all the subsequent elements are smaller than it. Secondly, any non-right leader will be removed as soon as the next right leader enters \(Q\). Finally, any element outside the window cannot be in \(Q\). By contradiction, let us assume that \(Q\) contains one such element, say \(a\). Let \(r\) be the largest right leader. On the one hand, \(a\) cannot be smaller than or equal to \(r\), otherwise \(a\) would be removed when inserting \(r\) in \(Q\). On the other hand, \(a\) cannot be larger than \(r\), otherwise, it would be in front of \(Q\) and removed by the first inner loop.</p> <p>We derive the correctness of the algorithm by combining the sortedness of \(Q\) with the fact that the largest right leader is the element to report.</p> <h4 id="time-complexity">Time complexity</h4> <p>Let us show that the algorithm runs in linear time.</p> <p>We first use the standard approach to analyze an algorithm. We have a loop that is repeated \(n\) times. What’s the cost of an iteration? Looking at the implementation it should be clear that its cost is dominated by the cost (and, thus, number) of pop operations. However, in a certain iteration, we may pop out all the elements in the deque. As far as we know there may be up to \(n\) elements in the deque and, thus, an iteration costs \(O(n)\) time. So, the best we can conclude is that the algorithm runs in \(O(n^2)\) time. Can’t go too far with this kind of analysis!</p> <p>In fact, there may indeed exist very costly iterations, but they are greatly amortized by several very cheap ones. Indeed, the overall number of pop operations cannot be larger than \(n\) as any element is not considered anymore by the algorithm as soon as it is removed from \(Q\). Each of them costs constant time and, thus, the algorithm runs in linear time.</p> <h2 id="next-larger-element">Next larger element</h2> <p>As an useful exercise, you could try to adapt the previous solution to solve the <em>Next larger element</em> problem, which is as follows.</p> <p><em>Given an array \(A[0,n-1]\) having distinct elements, the goal is to find the next greater element for each element of the array in order of their appearance in the array.</em></p>]]></content><author><name></name></author><category term="notes"/><category term="rust,"/><category term="algorithms"/><summary type="html"><![CDATA[Notes for the course Competitive Programming and Contests at University of Pisa]]></summary></entry></feed>